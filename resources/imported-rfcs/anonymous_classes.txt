
====== PHP RFC: Anonymous Classes ======
  * Version: 0.1
  * Date: 2013-09-22
  * Author: Joe Watkins, krakjoe@php.net
  * Status: Under Discussion
  * First Published at: http://wiki.php.net/rfc/anonymous_classes

===== Introduction =====

For some time PHP has featured anonymous function support in the shape of Closures; this patch introduces the same kind of functionality for objects of an anonymous class.

The ability to create objects of an anonymous class is an established and well used part of Object Orientated programming in other languages.

An anonymous class might be used over a named class:
  * when the class does not need to be documented
  * when the class is used only once during execution

The scope for use is so wide, it is hard to suggest specific use cases; the general use case is throw away implementation of interfaces and abstracts that meet the criteria above.

An anonymous class is a class without a (programmer declared) name, the functionality of the object is no different from that of an object of a named class.

Note: this patch lifts the normal limitation of anonymous classes to be used once, so this criteria only loosely applies ...

===== Use Cases =====

Following the general advice, the area of code testing appears to present the most significant number of use cases, however, where anonymous classes are a part of a language they do find their way into many areas of development, not just testing. Whether it is technically correct to use an anonymous class depends almost entirely on an individual application, or even object depending on perspective.

Anonymous classes do present the opportunity to create the first kind of nested class in PHP, you might nest for slightly different reasons to creating an anonymous class, so that deserves some discussion; 

<code php>
<?php
class Outside {
    protected $data;
    
    public function __construct($data) {
        $this->data = $data;
    }
    
    public function getArrayAccess() {
        return new class extends Outside implements ArrayAccess {
            public function offsetGet($offset) { return $this->data[$offset]; }
            public function offsetSet($offset, $data) { return ($this->data[$offset] = $data); }
            public function offsetUnset($offset) { unset($this->data[$offset]); }
            public function offsetExists($offset) { return isset($this->data[$offset]); }
        } ($this->data);
    }
}
?>
</code>

Note: Outer is extended not for access to $this->data - that could just be passed into a constructor; extending Outer allows the nested class implementing ArrayAccess permission to execute protected methods, declared in the Outer class, on the same $this->data, and if by reference, as if they are the Outer class.

In the simple example above Outer::getArrayAccess takes advantage of anonymous classes to declare and create an ArrayAccess interface object for Outer.

By making getArrayAccess private the anonymous class it creates can be said to be a private class. 

This increases the possibilities for grouping of your objects functionality, can lead to more readable, some might say more maintainable code.

The alternative to the above is the following:

<code php>
class Outer implements ArrayAccess {
    public $data;
    
    public function __construct($data) {
        $this->data;
    }
    
    public function offsetGet($offset) { return $this->data[$offset]; }
    public function offsetSet($offset, $data) { return ($this->data[$offset] = $data); }
    public function offsetUnset($offset) { unset($this->data[$offset]); }
    public function offsetExists($offset) { return isset($this->data[$offset]); }
    
    public function getArrayAccess() {
        return new Outer($this->data);
    } 
}
</code>

Note: getArrayAccess not strictly necessary, perhaps ... 

Pass-by-reference is not used in the examples above, so behaviour with regard to $this->data should be implicit.

How you choose to do it for any specific application, whether getArrayAccess is private or not, whether to pass by reference or not, depends on the application.

===== Backward Incompatible Changes =====

New syntax that will fail to parse in previous versions, so no BC breaks.

===== Proposed PHP Version(s) =====

5.6

===== SAPIs Impacted =====

All

===== Impact to Existing Extensions =====

No impact on existing libraries




===== Open Issues =====

The question of whether or not to disable serialization for anonymous objects.

===== Future Scope =====

This patch opens the door for, or appears to go hand in hand with, (named) nested classes
   https://github.com/krakjoe/php-src/compare/anon_class_objects...nested_classes 
which opens the door for access modification on class declarations (no patch yet)
which all makes for more flexible/powerful OO.

Note: the patch above is buggy, a proof of concept is all ...
===== Proposed Voting Choices =====

Straight forward, we should have this, we should not have this.

===== Syntax =====

new class {definition} (arguments)

The above syntax is used to avoid conflicts with existing rules in the grammar file.

Note: some have suggested that we should use new class(arguments) {definition}, this makes for a slightly more complex parser, additionally, it doesn't appear to make good sense to pass arguments to a constructor that may not have been declared, making this the simpler, more logical choice.

<code php>
<?php
/* implementing an anonymous console object from your framework maybe */
(new class extends ConsoleProgram {
    public function main() {
       /* ... */
    }
})->bootstrap();

/* return an anonymous implementation of a Page for your MVC framework */
return new class implements Page {
    public function __construct($controller) {
        /* ... */
    }
    /* ... */
} ($controller);

/* vs */
class MyPage implements Page {
    public function __construct($controller) {
        /* ... */
    }
    /* ... */
}
return new MyPage($controller);

/* return an anonymous extension of the DirectoryIterator class */
return new class extends DirectoryIterator {
   /* ... */
} ($path);

/* vs */
class MyDirectoryIterator {
    /* .. */
}
return new MyDirectoryIterator($path);

/* return an anon class from within another class (introduces the first kind of nested class in PHP) */
class MyObject extends MyStuff {
    public function getInterface() {
        return new class implements MyInterface {
            /* ... */
        };
    }
}


/* return a private object implementing an interface */
class MyObject extends MyStuff {
    /* suitable ctor */
    
    private function getInterface() {
        return new class extends MyObject implements MyInterface {
            /* ... */
        } (/* suitable ctor args */);
    }
}

?>
</code>

Note: the ability to declare and use a constructor in an anonymous class is necessary where control over construction must be exercised.

===== Code Paths =====

Code such as:

<code php>
while ($i++<10) {
    class myNamedClass {
        /* ... */
    }
}
</code>

will fail to execute, however code such as:

<code php>
while ($i++<10) {
  new class {};
}
</code>

will work as expected: the definition will be re-used, creating a new object.

===== Inheritance =====

Some have queried how inheritance might work and suggested the utilization of the "use" statement.

This doesn't appear to be necessary; //anonymous classes have constructors and support inheritance like any other class as the examples show.//

It seems to me that use(/* my local vars */) is not actually different from passing those arguments to a constructor, they are for all intents and purposes the same thing.


===== Implementation =====

https://github.com/php/php-src/pull/470

===== Rejected Features =====

N/A