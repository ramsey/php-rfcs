====== PHP RFC: Saner numeric strings ======
  * Version: 1.2
  * Date: 2020-06-28
  * Author: George Peter Banyard <girgias@php.net>
  * Status: Under Discussion
  * First Published at: http://wiki.php.net/rfc/saner-numeric-strings
  * Implementation: https://github.com/php/php-src/pull/5762

===== Technical Background =====
The PHP language has a concept of //numeric strings//, strings which can be interpreted as numbers. This concept is used in a few places:

  * Explicit conversions of strings to number types, e.g. <PHP>$a = "123";
$b = (float)$a; // float(123)</PHP>
  * Implicit conversions of strings to number types, e.g. in weak typing mode <PHP>$a = "123";
$b = intdiv($a, 1); // int(123)</PHP>
  * Comparisons, e.g. <PHP>$a = "123";
$b = "123.0";
$c = ($a == $b); // bool(true)</PHP>
  * The <php>\is_numeric()</php> function, e.g. <PHP>$a = "123";
$b = \is_numeric($a); // bool(true)</PHP>
  * String offsets, e.g. <PHP>$str = 'The world';
var_dump($str['4']);      // string(1) "w"
var_dump($str['03']);     // string(1) " "
var_dump($str['2str']);   // string(1) "e" with E_NOTICE "A non well formed numeric value encountered"
var_dump($str[' 1']);     // string(1) "h"
var_dump($str['5.5']);    // string(1) "o" with E_WARNING "Illegal string offset '5.5'"
var_dump($str['string']); // string(1) "T" with E_WARNING "Illegal string offset 'string'"
</PHP>

A string can be categorised in three ways according to its numeric-ness, as [[https://github.com/php/php-langspec/blob/be010b4435e7b0801737bb66b5bbdd8f9fb51dde/spec/05-types.md#the-string-type|described by the language specification]]:

  * A //numeric string// is a string containing only a [[https://github.com/php/php-langspec/blob/be010b4435e7b0801737bb66b5bbdd8f9fb51dde/spec/05-types.md#grammar-str-number|number]], optionally preceded by white-space characters. For example, <php>"123"</php> or <php>"  1.23e2"</php>.
  * A //leading-numeric string// is a string that begins with a numeric string but is followed by non-number characters  (including white-space characters). For example, <php>"123abc"</php> or <php>"123 "</php>.
  * A //non-numeric string// is a string which is neither a numeric string nor a leading-numeric string.

The difference between a numeric string and a leading-numeric string is significant, because certain operations distinguish between these:

  * <php>\is_numeric()</php> returns <php>TRUE</php> only for numeric strings
  * Arithmetic operations (e.g. <php>$a * $b</php>, <php>$a + $b</php>) accept and implicitly convert both numeric and leading-numeric strings, but trigger the <php>E_NOTICE</php> “A non well formed numeric value encountered” for leading-numeric strings
  * In weak typing mode (no ''strict_type'' declare statement or ''strict_types=0''), <php>int</php> and <php>float</php> parameter and return type declarations will accept and implicitly convert both numeric and leading-numeric strings, but likewise trigger the same <php>E_NOTICE</php>
  * Type casts and other explicit conversions to integer or float (e.g. <php>(int)</php>, <php>(float)</php>, <php>settype()</php>) accept all strings, converting both numeric and leading-numeric strings and producing 0 for non-numeric strings
  * String-to-string comparisons with <php>==</php>, <php>!=</php>, <php><></php>, <php><</php>, <php>></php>, <php><=</php>, and <php>>=</php> perform numeric comparison only if both strings are numeric strings
  * String-to-int/float comparisons with <php>==</php>, <php>!=</php>, <php><></php>, <php><</php>, <php>></php>, <php><=</php>, and <php>>=</php> type-juggle the string (and thus perform numeric comparison) if it is either a numeric string or a non-numeric string

It is notable that while a numeric string may contain leading white-space, only a leading-numeric string may contain trailing white-space.

A fourth way PHP might deal with numeric strings is when using an //integer// string for an array offset.
An integer string is stricter than numeric strings in two major ways:
  * It doesn't accept leading whitespaces
  * It doesn't accept leading zeros (0)
As stated above this is vastly different to the handling of strings offsets, as can be demonstrated in the following code snippet:
<PHP>
$a = [
    "4" => "Integer index",
    "03" => "Integer index with leading 0/octal",
    "2str" => "leading numeric string",
    " 1" => "leading whitespace",
    "5.5" => "Float",
];
var_dump($a);
</PHP>
Which results in the following output:

<code>
array(5) {
  [4]=>
  string(13) "Integer index"
  ["03"]=>
  string(34) "Integer index with leading 0/octal"
  ["2str"]=>
  string(22) "leading numeric string"
  [" 1"]=>
  string(18) "leading whitespace"
  ["5.5"]=>
  string(5) "Float"
}
</code>

===== The Problem =====

The current behaviour of numerical strings has various issues:
  * numeric strings with leading white-space are considered more numeric than numeric strings with trailing white-space
  * strings which happen to start with a digit, e.g. hashes, may at times be interpreted as numbers, which can lead to bugs
  * <php>\is_numeric()</php> is misleading, as it will reject values that a weak-mode parameter check will accept
  * leading-numeric strings is a rather strange concept and an unintuitive/surprising behaviour.

|                       ^ <php>is_numeric()</php> ^ Weak mode int type ^ Weak mode float type ^ Legal string offset ^ Legal Array index ^ Explicit(int) cast ^ Explicit(float) cast ^ ''== 123'' ^ ''== "123"'' ^
^  ''123''                |  ''true''   |  ''123''     |  <php>123.0</php>   |  ''123''  |  ''123''  |  ''123''  |  <php>123.0</php>  |  ''true''   |   ''true''   |
^  <php>'123'</php>       |  ''true''   |  ''123''     |  <php>123.0</php>   |  ''123''  |  ''123''  |  ''123''    |  <php>123.0</php>  |  ''true''   |   ''true''   |
^  <php>'  123'</php>     |  ''true''   |  ''123''     |  <php>123.0</php>   |  ''123''  |  <php>'  123'</php>     |  ''123''  |  <php>123.0</php>  |  ''true''   |   ''true''   |
^  <php>'123   '</php>    |  ''false''  |  ''123''  *  |  <php>123.0</php>*  |  ''123''  |  <php>'123   '</php>    |  ''123''  |  <php>123.0</php>  |  ''true''   |  ''false''  |
^  <php>'  123   '</php>  |  ''false''  |  ''123''  *  |  <php>123.0</php>*  |  ''123''  |  <php>'  123   '</php>  |  ''123''  |  <php>123.0</php>  |  ''true''   |  ''false''    |
^  <php>'123abc'</php>    |  ''false''  |  ''123''  *  |  <php>123.0</php>*  |  ''123''  |  <php>'123abc'</php>    |  ''123''  |  <php>123.0</php>  |  ''true''   |  ''false''  |
^  <php>'string'</php>    |  ''false''  |  ''TypeError''    |  ''TypeError''      |  ''0''°    |  <php>'string'</php>    |  ''0''  |  <php>0.0</php>    |  ''false''  |  ''false''  |
Items denoted with * indicate that an <php>E_NOTICE</php> “A non well formed numeric value encountered” is emitted.
Items denoted with ° indicate that an <php>E_WARNING</php> “Illegal string offset” is emitted.

===== Proposal =====
Unify the various numeric string modes into a single concept: Numeric characters only with both leading and trailing whitespace allowed.

This means, all strings which currently emit the <php>E_NOTICE</php> “A non well formed numeric value encountered” will emit the <php>E_WARNING</php> “A non-numeric value encountered” //except// if the leading-numeric string contained only trailing white-spaces or if the operation used explicit int casting semantics.

For string offsets accessed using numeric strings the following changes will be made:
  * numeric strings which correspond to well formed floats will emit the more usual “String offset cast occurred” warning instead of the “Illegal string offset” one.
  * leading numeric strings will emit the “Illegal string offset” instead of the “A non well formed numeric value encountered” notice, and continue to evaluate to their respective values.
  * Non-numeric strings which emitted the “Illegal string offset” warning will throw an “Illegal offset type” TypeError

For the PHP interpreter, this would be accomplished by modifying the ''is_numeric_string'' C function (and its variants) in the Zend Engine. This would therefore affect PHP features which make use of this function, including:

  * [[rfc:invalid_strings_in_arithmetic|Arithmetic operators]]
  * The <php>int</php> and <php>float</php> type declarations
  * Type checks for built-in/extension (“internal”) PHP functions
  * The comparison operators will now consider numeric strings with trailing white-space to be numeric, therefore meaning that, for example, <php>"123  " == "  123"</php> produces <php>true</php>, instead of <php>false</php>
  * The <php>\is_numeric</php> function would return <php>true</php> for numeric strings with trailing white-space
  * The <php>++</php> and <php>--</php> operators would convert numeric strings with trailing white-space to integers or floats, as appropriate, rather than applying the alphanumeric increment rules

The PHP language specification's [[https://github.com/php/php-langspec/blob/master/spec/05-types.md#the-string-type|definition of str-numeric]] would be modified by the addition of ''str-whitespace''<sub>''opt''</sub> after ''str-number'' and the removal of the following sentence: "A leading-numeric string is a string whose initial characters follow the requirements of a numeric string, and whose trailing characters are non-numeric".

For the string offset behaviour changes the following C Zend engine function and their JIT equivalent will be modified ''zend_check_string_offset()'' and ''zend_fetch_dimension_address_read()''.

===== Backward Incompatible Changes =====
There are two backward incompatible changes:
  * code relying on numerical strings with trailing white-spaces to be considered non-well-formed
  * code with liberal use of leading-numerical strings will need to be updated

The first reason is a precise requirement and therefore should be checked explicitly. A small polyfill to check for the previous <php>is_numeric()</php> behaviour:
<PHP>if (is_numeric($str) && strlen($str) === strlen(rtrim($str)) ){...}</PHP>

Breaking the second reason will allow to catch various bugs ahead of time, and the previous behaviour can be obtained by adding explicit casts, e.g.:
<PHP>
var_dump((int) "2px"); // int(2)
var_dump((float) "2px"); // float(2)
var_dump((int) "2.5px"); // int(2)
var_dump((float) "2.5px"); // float(2.5)
</PHP>

Some notable cases are:
  * Arithmetic operations: <php>var_dump('5b' + 'c');</php>, currently:
<code>
Notice: A non well formed numeric value encountered

Warning: A non-numeric value encountered
int(5)
</code>
With the proposal accepted:
<code>
Warning: A non-numeric value encountered

Warning: A non-numeric value encountered
int(0)
</code>
  * Type declarations:
<PHP>function foo(int $i) { var_dump($i); }
foo('5 ');
foo('5b');</PHP>
currently:
<code>Notice: A non well formed numeric value encountered in /in/ZoOdK on line 3
int(5)

Notice: A non well formed numeric value encountered in /in/ZoOdK on line 3
int(5)</code>
With the proposal accepted:
<code>int(5)
Fatal error: Uncaught TypeError: foo(): Argument #1 ($i) must be of type int, string given</code>

  * Increment/Decrement ops
<PHP>
$a = "5z";
var_dump(++$a);
$b = "5 ";
var_dump(++$b);
</PHP>
Currently:
<code>
string(2) "6a"
string(2) "5 "
</code>
With the proposal accepted:
<code>
string(2) "6a"
int(6)
</code>
===== Proposed PHP Version =====
PHP 8.0.

===== RFC Impact =====
==== To Existing Extensions ====
Any extension using the C ''is_numeric_string'', its variants, or other functions which themselves use it, will be affected.

==== To Opcache ====
None that I am aware of.

===== Unaffected PHP Functionality =====
This does not affect the filter extension, which handles numeric strings itself in a different fashion.

===== Future Scope =====
  * Nikita Popov's [[rfc:string_to_number_comparison|PHP RFC: Saner string to number comparisons]]
  * Adding an E_NOTICE for numerical strings with leading/trailing white-spaces
  * Adding a flag to <php>\is_numeric</php> to accept or reject numerical strings with leading/trailing white-spaces
  * Align string offset behaviour with array offsets
  * Promote remaining "Illegal string offset" warnings to Type Errors in PHP 9
  * Warn on illegal offsets when used within <php>isset()</php> or <php>empty()</php>

===== Proposed Voting Choices =====
Per the Voting RFC, there would be a single Yes/No vote requiring a 2/3 majority.

===== Patches and Tests =====
A pull request for a complete PHP interpreter patch, including a test file, can be found here: https://github.com/php/php-src/pull/5762

A language specification patch still needs to be done.

A possible documentation patch still needs to be done.

===== Implementation =====
After the project is implemented, this section should contain 
  - the version(s) it was merged to
  - a link to the git commit(s)
  - a link to the PHP manual entry for the feature
  - a link to the language specification section (if any)
  
===== Acknowledgement =====
To Andrea Faulds for the [[http://wiki.php.net/rfc/trailing_whitespace_numerics|PHP RFC: Permit trailing whitespace in numeric strings]] on which this RFC and patch is based of.

===== Changelog =====
  * 2020-07-02: Explain difference between array and string offsets, and how the RFC will impact string offsets
  * 2020-07-01: Add explicit cast behaviour for leading numeric strings
  * 2020-06-28: Initial version