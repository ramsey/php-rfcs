====== PHP RFC: Deprecate dynamic properties ======
  * Date: 2021-08-23
  * Author: Nikita Popov <nikic@php.net>
  * Status: Draft
  * Target Version: PHP 8.2
  * Implementation: https://github.com/php/php-src/pull/7390

===== Introduction =====

When writing to a property that has not been declared, PHP will silently create a dynamic property instead. In modern code, this is rarely done intentionally. This RFC proposes to deprecate and later remove the creation of dynamic properties for non-stdClass objects.

<PHP>
class User {
    public $name;
}

$user = new User;

// Assigns declared property User::$name.
$user->name = "foo";

// Oops, a typo:
$user->nane = "foo";
// PHP < 8.1: Silently creates dynamic $user->nane property.
// PHP   8.2: Throws deprecation warning, still creates dynamic property.
// PHP   9.0: Throws Error exception.
</PHP>

"Dynamic property" here refers to a property that has not been declared in the class. It has no relation to the access style (e.g. ''$user->{'na' . 'me'}'' is still an access to a declared property).

===== Proposal =====

The creation of dynamic properties on classes that don't inherit from ''stdClass'' is deprecated in PHP 8.2 and becomes an Error exception in PHP 9.0. All used properties should be declared in the class declaration.

<PHP>
class Foo {}
$foo = new Foo;

// Deprecated: Creation of dynamic property Foo::$bar is deprecated
$foo->bar = 1;

// No deprecation warning: Dynamic property already exists.
$foo->bar = 2;
</PHP>

Objects of type ''stdClass'' and inheriting classes continue to support dynamic properties.

<PHP>
$obj = (object) []; // = new stdClass;

// No deprecation warning
$obj->foo = 1;

class myStdClass extends stdClass {}
$obj2 = new myStdClass;

// No deprecation warning
$obj2->bar = 1;
</PHP>

''stdClass'' objects are specifically intended to hold dynamic properties. ''extends stdClass'' is offered as a simple migration strategy for custom classes that are also specifically intended for use with dynamic properties.

It should be noted that properties accessed through ''%%__get()%%''/''%%__set()%%'' are not considered as "dynamic properties". The following example does not generate any deprecation warnings:

<PHP>
class ArrayLikeObject {
    private array $data = [];
    public function &__get($name) { return $this->data[$name]; }
    public function __isset($name, $value) { return isset($this->data[$name]; }
    public function __set($name, $value) { $this->data[$name] = $value; }
    public function __unset($name) { unset($this->data[$name]; }
}

$obj = new ArrayLikeObject;

// Calls ArrayLikeObject::__set(), no deprecation warning.
$obj->foo = 1;
</PHP>

===== Backward Incompatible Changes =====

Removing support for dynamic properties constitutes a significant backwards compatibility break. While modern PHP code consistently declares used properties, this is not necessarily the case for legacy code. When encountered with a dynamic property deprecation warning, there are a number of things that can be done to avoid it.

The simplest and most common would be to simply add the property declaration:

<PHP>
class Test {
    public $value; // <-- Add property declaration.

    public function __construct($value) {
        $this->value = $value;
    }
}
</PHP>

For classes that intentionally don't have a fixed set of properties, it's possible to either implement magic ''%%__get()%%''/''%%__set()%%'', or to extend from the ''stdClass'' class, or from ''ArrayObject'' in ''ARRAY_AS_PROPS'' mode. 

Using magic getters/setters provides the most control, but extending from ''stdClass'' will make dynamic property accesses more efficient by using optimized engine hooks. It will also match the current behavior most closely, for example with regard to the behavior of ''foreach'' or ''property_exists()''.

In some cases it is desirable to associate information with objects that you do not own. Previously, it was possible to add a dynamic property for this purpose. Instead, a ''WeakMap'' should be used to store the information in a non-intrusive way:

<PHP>
class Test {
    private WeakMap $extraInfo;

    public function addExtraInfo(object $obj) {
        // Instead of:
        $obj->extraInfo = ...;
        // Use:
        $this->extraInfo[$obj] = ...;
    }
}
</PHP>

In rare cases, dynamic properties are used for lazy initialization. For example Symfony's [[https://github.com/symfony/symfony/blob/6.0/src/Symfony/Component/Validator/Constraint.php|Constraint::$groups]] property is not declared and then dynamically created inside ''%%__get()%%''. This use-case can be accommodated by declaring the property, but then unsetting it in the constructor:

<PHP>
abstract class Constraint {
    public $groups;

    public function __construct() {
        unset($this->groups);
    }

    public function __get($name) {
        // Will get called on first access, but once initialized.
        $this->groups = ...;
    }
}
</PHP>

A declared property that has been unset remains a declared property, and will not result in a dynamic property when it is reinitialized.

===== Vote =====

Yes/No.