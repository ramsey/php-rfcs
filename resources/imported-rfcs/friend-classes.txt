====== PHP RFC: Class Friendship ======
  * Version: 0.1
  * Date: 2015-12-10
  * Author: Dustin Wheeler, mdwheele@ncsu.edu
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/friend-classes



===== Introduction =====
There are currently several discussions around the topic of limited-visibility collaborators amongst the PHP community. Among these, an effort for "package-private" or otherwise vendor-namespaced private collaborators has been suggested as a solution to the problem that is currently solved through convention; exposing implementation details to public scope and use doc-block "@internal" tags to mark as "do not touch"! This is sometimes a necessary evil in frameworks and other core components. However, this is not the only use-case for enabling per-class access to an object's internal state. Enabling collaborator access to protected properties has application in testing as well as better expressing a tight coupling between classes for the purposes of better encapsulation of behaviour; while affording presentation concerns to be separated.

Class Friendship allows a class to be better encapsulated by granting per-class access to protected properties that would otherwise have to be marked public. This affords developers an opportunity to better model objects as behavioural units while making explicit presentation concerns through friendship. Admittedly, class friendship has a narrow use-case, but is nonetheless a valuable expression for object modeling when used properly. 

It also has value in Characterization Testing as a short-term strategy for refactoring legacy applications and provides a natural marker / target for further work through explicit friend relationships between Systems Under Test and their test cases.

===== Proposal =====
Support for class friendship is added through a new keyword, ''friend''. It allows per-class access to protected properties as follows:

==== Basic Usage ====
A subject class (''Person'') may declare another class a ''friend'' (''PersonFormatter''). This enables the named ''friend'' class access to protected properties of the subject. There are other properties of Class Friendship, as implemented in C++, but this is the basic feature shown through separating presentation concerns away from a domain object.

<code php>
class Person
{
    friend PersonFormatter;
    
    protected $firstName;
    protected $lastName;

    public function __construct($firstName, $lastName)
    {
        $this->firstName = $firstName;
        $this->lastName = $lastName;
    }

    public function format()
    {
        return new PersonFormatter($this);
    }
}

class PersonFormatter
{
    private $person;
    
    public function __construct(Person $person)
    {
        $this->person = $person;
    }

    public function getFullName()
    {
        // PersonFormatter would not have access to protected properties
        // of Person if not explicitly listed as a friend.
        return $this->person->firstName . ' ' . $this->person->lastName;
    }
}

$person = new Person('Alice', 'Wonderland');
$formatter = $person->format();

var_dump($formatter->getFullName()); // string(16) "Alice Wonderland"
</code>

Class friendship can also be used to implement characterization tests as part of a refactoring project for legacy applications. Consider the following class responsible for executing a Fibonacci sequence:

<code php>
class Fibonacci
{
    friend FibonacciTest

    protected $previous;
    protected $current;
    
    public function __construct()
    {
        $this->previous = 0;
        $this->current = 0;
    }
    
    public function next()
    {
        $current = $this->current;
        $next = $this->previous + $this->current;
        
        if ($next == 0) { 
            $next = 1; 
        }

        $this->previous = $this->current;
        $this->current = $next;
        
        return $current;
    }
}

class FibonacciTest
{
    public function testAssignmentAlgoForStateIsCorrect()
    {
        $fibo = new Fibonacci();
        
        $this->assertEquals(0, $fibo->previous);
        $this->assertEquals(0, $fibo->current);
        
        $n0 = $fibo->next();
        
        $this->assertEquals(0, $n0);
        $this->assertEquals(0, $fibo->previous);
        $this->assertEquals(1, $fibo->previous);
        
        // ... and so on ...
    }
}
</code>

Characterization Tests are extremely useful for describing the **actual** behaviour of a unit. They are usually a temporary measure used to verify that modifications made to a system to not have unintended or undesirable changes in **how** the system works. They are also a good marker for follow-up work to encapsulate behaviours into objects. 

Currently, in many examples, we have to either change visibility of properties that only exist for implementation **or** provide meaningless getters to these properties; thus polluting the public API of the object and risking abuse by other objects. We really want to declare a limited set of collaborators privileged access to these properties for a single purpose.

==== Other Properties ====
There are several rules of class friendship that clarify how the feature works with regard to direction, transitivity and inheritance. 
 
=== Friendships are not symmetric ===
If ''PersonFormatter'' is a friend of ''Person'', ''Person'' is **NOT** automatically a friend of ''PersonFormatter''

=== Friendships are not transitive ===
If class A is a friend of class B, and class B is a friend of class C, class A is not automatically a friend of class C.

=== Friendships are not inherited ===
A friend of class Base is not automatically a friend of class Derived and vice versa; equally if Base is a friend of another class, Derived is not automatically a friend and vice versa.

=== Access due to friendship is inherited ===
A friend of Derived can access the restricted members of Derived that were inherited from Base. Note though that a friend of Derived only has access to members inherited from Base to which Derived has access itself, e.g. if Derived inherits publicly from Base, Derived only has access to the protected (and public) members inherited from Base, not the private members, so neither does a friend.

==== Errors ====
In all cases above, the error message received is no different than if you attempted to access private or protected properties of a class through traditional means. That is to say, the error message will not hint ''"Whoops! You don't have access to this property because friendship isn't symmetric."''. 

==== Additional Thoughts ====
I have purposely kept this RFC fairly slim for a number of reasons. First and foremost, I want to make it clear that I do **not** see this feature in competition with any other RFC or suggestion for limited-visibility collaborators. Rather, I see it working in concert with something like namespace visibility or package-privacy. I feel that class friendship is about object modeling and making explicit privileged relationships between two or more classes. It is a form of tighter coupling to achieve better encapsulation of behaviour.

Secondly, the RFC is purposefully (yet still usefully) slim to "test the waters" on such a feature for inclusion in PHP. This may not be the most popular feature in the world, but I believe that it does scratch a considerable itch for the testing and object modeling communities overlapping the PHP community. This RFC fulfills an 80% use-case (80/20) for the spirit of class friendship and paves the way for further implementation of:

  * Friendship to global function
  * Friendship to a single class method
  * Friendship to a namespace (caveat)

While namespace friendship might seem like a good idea, it is actually more "in the vein" of "package-privacy" or "namespace visibility" and begins to leave what many consider the spirit of class friendship. There are uses where this is not the case, which is why I have included it. 

===== Proposed PHP Version(s) =====
This proposal targets the next minor version of PHP, which at the time of this writing is PHP 7.1.

===== RFC Impact =====
==== To Opcache ====
This is an open issue pending code review. 

===== Open Issues =====
==== Policy ====
  * Implementation requires code review to advise on improvements as well as inform that opcache was appropriately considered.
  * Verify current PHP functionality around class property visibility is undisturbed

===== Future Scope =====
While this RFC specifies friendship between classes, there is opportunity to extend this implementation and syntax:

  * Implement class friendship to a global function 
  * Implement class friendship to a collaborating class method
  * Implement class friendship to a name space

===== Proposed Voting Choices =====
As this is a language change, a 2/3 majority is required. (see [[voting]])

===== Patches and Tests =====
I have implemented the RFC as described with tests to verify all usage examples above. I will link this as soon as I am able and will open a pull request against ''master'' to monitor TravisCI build status as I make changes.

As this is my first contribution to PHP, it is my opinion that my request should be placed under higher scrutiny and I am completely ready and willing to accept all feedback to improve implementation.

===== References =====
  - https://bugs.php.net/bug.php?id=34044
  - http://stackoverflow.com/questions/317835/php-equivalent-of-friend-or-internal
  - https://marc.info/?l=php-internals&m=144639394529142
  - http://ocramius.github.io/blog/accessing-private-php-class-members-without-reflection/
  - http://www.stroustrup.com/hopl2.pdf
  - http://tekwire.net/joomla/projects/ideas/php-friend

===== Changelog =====
  * v0.1 - Created