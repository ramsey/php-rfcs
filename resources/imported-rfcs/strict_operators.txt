====== PHP RFC: Strict operators directive ======
  * Version: 0.1
  * Date: 2019-05-25
  * Author: Arnold Daniels, jasny@php.net
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/strict_operators


===== Introduction =====
<del>This RFC proposes the addition of a new optional per-file directive, ''declare(strict_operators=1);'', which makes all operators within a file have "strict" type-checking. Using operators with incompatible types with this directive throws a ''TypeError''.

The directive addresses all issues related to type juggling by operators in a backward compatible way, following the same rationale as [[rfc:scalar_type_hints_v5|PHP RFC: Scalar Type Declarations]]. Please make sure you've read the //Background and Rationale// section of that RFC. 

PHP supports two different types of comparison operators: The strict comparisons ''==='' and ''!=='', and the non-strict comparisons ''=='', ''!='', ''>'', ''>='', ''<'', ''%%<=%%'' and ''%%<=>%%''. The primary difference between them is that strict comparisons require both operands to be of the same type, and do not perform implicit type coercions.

The current dogma in the PHP world is that non-strict comparisons should **always** be avoided because their conversion semantics are rarely desirable and can easily lead to bugs or even security issues. This is an issue for ''>'', ''>='', ''<'', ''%%<=%%'' and ''%%<=>%%'' as no strict alternative of these operators exist. Using the non-strict operators can lead to unexpected behavior.</del>

==== Mixed type comparison ====
Mathematics states that "if ''(a > b)'' and ''(b > c)'', then ''(a > c)''". This statement can be asserted in PHP;

<code php>
if (($a > $b) && ($b > $c)) {
    assert($a > $c);
}
</code>

This assertion fails when choosing different values of different types

<code php>
$a = '42';
$b = 10;
$c = '9 eur';

if (($a > $b) && ($b > $c)) {
    assert($a > $c);
}
</code>

==== Numeric string comparison ====
Non-strict comparison uses a "smart" comparison method that treats strings as numbers if they are numeric. The meaning of the operator, changes based on the value of both operands.

Using the ''%%<=>%%'' operator to ordering the values of an array, can lead to different results based on the initial state of the array.

<code php>
function sorted(array $arr) {
  usort($arr, function($x, $y) { return $x <=> $y; });
}

sorted(['100', '5 eur', '62']); // ['100', '5 eur', '62']
sorted(['100', '62', '5 eur']); // ['5 eur', '62', '100']
sorted(['62', '100', '5 eur']); // ['62', '100', '5 eur']
</code>

==== Array comparison ====
Using the ''>'', ''>='', ''<'', ''%%<=%%'' and ''%%<=>%%'' operator on arrays or objects that don't have the same keys in the same order gives unexpected results.

In the following example ''$a'' is both greater than and less than ''$b''

<code php>
$a = ['x' => 1, 'y' => 22];
$b = ['y' => 10, 'x' => 15];

$a > $b; // true
$a < $b; // true
</code>

Omitting keys and other variations yield completely different results, like both comparisons resulting in `false` or a situation similar to the one seen with type juggling, where ''(a > b)'' and ''(b > c)'', but ''(a < c)''.

==== Type juggling of arithmetic operators ====
The behavior of arithmetic operators for non-scalar types is inconsistent.

Most arithmetic operations throw an ''Error'' if one of the operands is an array. But modulo and exponentiation operations will cast (to 0 or 1) and thus succeed silently.

Objects and resources are always cast to integers or floats. In case of an object, this results in a notice. For resources, this will succeed silently using the resource id as number.

|           ^ ''$a + 10''  ^ ''$a * 10''  ^ ''$a % 10''  ^
^ array     | error        | error        | -            |
^ object    | notice       | notice       | notice       |
^ resource  | -            | -            | -            |

==== Numeric strings and bitwise operators ====
Bitwise operators have an alternative operation is both operands are strings. This is regardless of the value of the strings.

> If both operands for the &, | and ^ operators are strings, then the operation will be performed on the ASCII values of the characters that make up the strings and the result will be a string. In all other cases, both operands will be converted to integers and the result will be an integer.

Bitwise operators are therefor the only operators that don't treat numeric strings as numbers.

<code php>
"22" & "12"; // "02"
22 & 12;     // 4
</code>

==== Strict vs non-strict comparison of arrays ====
Strict comparison requires that arrays have keys occurring in the same order, while non-strict comparison allows out-of-order keys.

<code php>
['a' => 'foo', 'b' => 'bar'] == ['b' => 'bar', 'a' => 0]; // true
</code>

To compare the values of two arrays in a strict way, while not concerned about the order requires ordering the array by key.

===== Proposal =====
By default, all PHP files are in weak type-checking mode for operators. A new ''declare()'' directive is added, ''strict_operators'', which takes either ''1'' or ''0''. If ''1'', strict type-checking mode is used for operators in the the file. If ''0'', weak type-checking mode is used.

In strict type-checking mode, operators may cast operants to the expected type. However;

  * Typecasting is not based on the type of the other operant
  * Typecasting is not based on the value of any of the operants
  * Operants will throw a ''TypeError'' for unsupported types

In case an operator can work with several (or all) types, the operands need to match as no casting will be done by those operators.

The one exception is that [[http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.2|widening primitive conversion]] is allowed for ''int'' to ''float''. This means that parameters that declare ''float'' can also accept ''int''.

<code php>
declare(strict_operators=1);

1.2 + 2; // float(3.2)
</code>

In this case, we're passing an ''int'' to a function that accepts ''float''. The parameter is converted (widened) to float.

==== Comparison operators ====
Comparison operators work on all scalar types. The types of both values need to match.

Non-scalar types only support the ''=='', ''==='', ''!='' and ''!=='' operators.

<code php>
"foo" > "bar";  // true
"foo" > 10;     // TypeError("Type mismatch string and int on greater than (>) operator")

"foo" == "bar"; // false
"foo" == 10;    // TypeError("Type mismatch string and int on equals (==) operator")
"foo" == null;  // TypeError("Type mismatch string and null on equals (==) operator")

true > false;   // true
true != 0;      // TypeError("Type mismatch bool and int on not equals (!=) operator")

[10] > [];      // TypeError("Unsupported type array on greater than (>) operator")
[10] == [];     // false
</code>

The function of the ''==='' and ''!=='' operators remains unchanged.

=== Numeric string comparison ===
Numeric strings are compared the same way as non-numeric strings. To compare two numeric strings as numbers, they need to be cast to floats.

<code php>
"120" > "99.9";               // false
(float)"120" > (float)"99.9"; // true

"120" <=> "99.9";             // -1
</code>

=== Array comparison ===
Comparing two arrays will never throw a ''TypeError''.

The difference between using the ''=='' and ''==='' operator is the order of the keys of the array. This feature remains unchanged.

Scalar values in the array are compared using both type and value, thus similar to the ''==='' operator. Objects of the same class will be compared similarly to the `==` operator, while objects of classes are always seen as not equal.

<code php>
['a' => 'foo', 'b' => 'bar'] == ['b' => 'bar', 'a' => 'foo'];  // true
['a' => 'foo', 'b' => 'bar'] === ['b' => 'bar', 'a' => 'foo']; // false

['a' => 'foo', 'b' => 'bar'] == ['b' => 'bar', 'a' => 0];      // false (no type juggling)
</code>

=== Object comparison ===
Comparing two objects of different classes using the ''=='' or ''!='' operator will throw a ''TypeError''.

<code php>
class Foo {
  public $x;
  
  public function __construct($x) {
    $this->x = $x;
  }
}

class FooBar extends Foo {}

(new Foo(10)) == (new Foo(10));     // true
(new Foo(10)) == (new Foo(99));     // false
(new Foo(10)) === (new Foo(10));    // false

(new Foo(10)) == (new FooBar(11));  // TypeError("Type mismatch Foo object and FooBar object on equals (==) operator")
(new Foo(10)) === (new FooBar(11)); // false
</code>

Comparing two objects of the same class will with these operators checks the properties of the objects. By default, properties are compared in a similar fashion to the ''==='' operator. If the property of both objects contains arrays or objects of the same class, they're compared as using the ''=='' operator.

==== Arithmetic operators ====
Arithmetic operators will only work with integers and floats. Using operants of any other type will result in a ''TypeError''.

In strict type-checking mode, the behavior of the operator is not determined by the value of the operands. Thus for any string, including numeric strings, a ''TypeError'' is thrown, so strings need to be explicitly cast.

The ''+'' operator is still available for arrays as union operator, requiring both values to be arrays.

==== Incrementing/Decrementing operators ====
The incrementing/decrementing operators will throw a ''TypeError'' when the operand is a boolean, null, array, object or resource. The decrementing operator will also throw a ''TypeError'' if the operand is a string.

The function of these operators for integers and floats remains unchanged.

=== Incrementing strings ===
The ''++'' operator for strings will largely remain unchanged, but it will behave consistently for any string, including numeric string. This means that using ''++'' on a string will always result in a string.

<code php>
$a = "00";
++$a; // "01"
++$a; // "02"
++$a; // "03"
</code>

==== Bitwise Operators ====
Bitwise operators expect both parameters to be an integer. The ''&'', ''|'' and ''^'' operators also accept strings as operants.

Using strings for ''~'', ''>>'' or ''<<'', mixing strings with integers or using any other type will throw a ''TypeError''.

==== String Operators ====
The concatenation operator ''.'' will throw a ''TypeError'' if any of the operands is a boolean, array or resource. It will also throw a ''TypeError'' if the operand is an object that doesn't implement the ''__toString()'' method.

Integers, floats, null and objects (with the ''toString()'' method) are cast to a string.

==== Logical Operators ====
The function of logical operators remains unchanged. All operands are cast to booleans.


===== Backward Incompatible Changes =====
None


===== Discussion =====

==== Narrowing the scope (strict_comparison) ====
This directive would only affect comparison operators. The behavior of other directives remains unchanged.

**Argument;** There's a difference between making a change to solve a clear problem (type-juggled comparison operators), and making a change just to be consistent.

==== Widening the scope (strong_types) ====
This directive would disable type juggling all together. This includes control statements like ''if'' and ''when''.

Using non-scalar values for array keys would throw a ''TypeError'' rather than issuing a warning. Using floats and booleans like ''$array[12.34]'' also silently cast to an integer, these might also throw a ''TypeError''.

**Argument;** Weak dynamic typing is criticized by a majority of software developers. Issues related to weak typing extend beyond operators. PHP would benefit from an option to disable this.

==== Should == and != always a return a boolean? ====
We could consider letting ''=='' and ''!='' do a type check and always return ''false'' in case the type is different. This would make them work similarly to some other languages like Python.

However, PHP already has the ''==='' and ''!=='' operator to accomplish this and thus can use ''=='' and ''!='' for strict type comparision. Using ''!='' and ''=='' adds the check that you have the expected types and you don't get an unexpected (silent) ''false'' on statements like ''10 == "10"''.

==== Can we use the existing strict_types directive? ====
Rather than using a new directive, we could also use ''strict_types'' with different values, eg ''declare(strict_types=functions,operators)'' or ''declare(strict_types=2)''.

==== Switch statement should also be affected ====
The ''switch'' statement also does a comparison operation and could do a strict comparison when this directive is used. On the other hand ''switch'' is not an operator.


===== Unaffected PHP Functionality =====
This RFC

  * does not affect any functionality concerning explicit type casting.
  * does not affect variable casting that occurs in (double-quoted) strings.
  * is largely unaffected by other proposals like [[rfc:string_to_number_comparison|PHP RFC: Saner string to number comparisons]] that focus on improving type juggling at the cost of breaking BC.


===== Proposed Voting Choices =====
Include these so readers know where you are heading and can discuss the proposed voting options.


===== Patches and Tests =====
A patch will be created by my after this RFC has been discussed.


===== Rejected Features =====
