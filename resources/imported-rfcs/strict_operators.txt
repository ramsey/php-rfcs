====== PHP RFC: Strict operators directive ======
  * Version: 0.1
  * Date: 2019-05-25
  * Author: Arnold Daniels, jasny@php.net
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/strict_operators


===== Introduction =====
This RFC proposes the addition of a new optional per-file directive, ''declare(strict_operators=1);'', which makes all operators within a file have "strict" type-checking. Using operators with incompatible types with this directive throws a ''TypeError''.

The directive addresses all issues related to type juggling in a backward compatible way, following the same rationale as [[rfc:scalar_type_hints_v5|PHP RFC: Scalar Type Declarations]]. Please make sure you've read the //Background and Rationale// section of that RFC. 

//This RFC contains some examples of unexpected behavior but isn't intended as a complete list.//

==== Comparison operators ====
PHP supports two different types of comparison operators: The strict comparisons ''==='' and ''!=='', and the non-strict comparisons ''=='', ''!='', ''>'', ''>='', ''<'', ''%%<=%%'' and ''%%<=>%%''. The primary difference between them is that strict comparisons require both operands to be of the same type, and do not perform implicit type coercions.

The current dogma in the PHP world is that non-strict comparisons should **always** be avoided because their conversion semantics are rarely desirable and can easily lead to bugs or even security issues. This is an issue for the ''>'', ''>='', ''<'', ''%%<=%%'' and ''%%<=>%%'' operators as no strict alternative of these operators exist. Using the non-strict operators can lead to unexpected behavior.

=== Type juggling ===
Logic dictates that if ''(a > b)'' and ''(b > c)'' then ''(a > c)'' **must** be true. In PHP, these elementry rules do not hold up due to type juggling;

<code php>
$a = '42';
$b = 10;
$c = '9 eur';

$a > $b; // true
$b > $c; // true
$a > $c; // false
</code>

=== Numeric string comparison ===
Non-strict comparison uses a "smart" comparison method that treats strings as numbers if they are numeric. This can lead to similar issues as with type juggling.

Using the ''%%<=>%%'' operator to ordering the values of an array, can lead to different results based on the initial state of the array.

<code php>
function sorted(array $arr) {
  usort($arr, function($x, $y) { return $x <=> $y; });
}

sorted(['100', '5 eur', '62']); // ['100', '5 eur', '62']
sorted(['100', '62', '5 eur']); // ['5 eur', '62', '100']
sorted(['62', '100', '5 eur']); // ['62', '100', '5 eur']
</code>

=== Key order ===
Strict comparison requires that arrays have keys occurring in the same order, while non-strict comparison allows out-of-order keys.

To compare the values of two arrays in a strict way, while not concerned about the order requires ordering the array by key.

=== Key mismatch ===
Using the ''>'', ''>='', ''<'', ''%%<=%%'' and ''%%<=>%%'' operator on arrays or objects that don't have the same keys in the same order gives unexpected results.

In the following example ''$a'' is both larger and smaller than ''$b''

<code php>
$a = ['x' => 1, 'y' => 22];
$b = ['y' => 10, 'x' => 15];

$a > $b; // true
$b < $a; // true
</code>

Omitting keys and other variations yield completely different results, like both comparisons resulting in `false` or a situation similar to the one seen with type juggling, were ''a > b'' and ''b > c'', but ''a < c''.

==== Arithmetic and Incrementing operators ====
The way arithmetic and incrementing/decrementing operators behave with non-numeric values is inconsistent.

=== Strings ===
Additional checks are placed on the arithmetic operators, looking at the value of a string to give a notice on a non-well formed numeric value and a warning on a non-numeric value.

Incrementing and decrementing operators do not have the same check. They will cast a numeric string, but will not give a notice or warning for non-numeric strings.

<code php>
$a = "10 foo";
$a = $a + 1;   // 11 (with notice)

$b = "10 foo";
$b++;          // "10 fop" 

$b = "10 foo";
$b--;          // "10 foo" (unchanged)
</code>

=== Array, objects and resources ===
An array throws an ''Error'' for most arithmetic operations, but cast for modulo and exponentiation operations. Objects and resources are always cast to integers or floats. In case of an object, this results in a notice. For resources, this will succeed silently using the resource id as number.

The behavior for incrementing/decrementing operators is different. No error, warning or notice is triggered. The operation is simply ignored.

|           ^ ''$a * 10''  ^ ''$a / 10''  ^ ''$a % 10''  ^ ''%%$a ** 10%%''  ^ ''$a++''  ^
^ array     | error        | error        | cast         | cast              | nop       |
^ object    | notice       | notice       | notice       | notice            | nop       |
^ resource  | cast         | cast         | cast         | cast              | nop       |

==== Bitwise Operators ====
Bitwise operators behave differently for string values.

> If both operands for the &, | and ^ operators are strings, then the operation will be performed on the ASCII values of the characters that make up the strings and the result will be a string. In all other cases, both operands will be converted to integers and the result will be an integer.

With that, bitwise operators are the only operators that don't treat numeric strings as numbers.

<code php>
"22" & "12"; // "02"
22 & 12;     // 4
</code>

==== Switch control structure ====
The ''switch'' statement does a non-strict comparison. This can lead to unexpected results;

<code php>
function match($value)
{
  switch ($value) {
    case 2:
      return "double";
      break;
    case 1:
      echo "single";
      break;
    case 0:
      echo "none";
      break;
    default:
      throw new Exception("Unexpected value");
  }
}

match("foo"); // "none"
</code>

===== Proposal =====
By default, all PHP files are in weak type-checking mode for operators. A new ''declare()'' directive is added, ''strict_operators'', which takes either ''1'' or ''0''. If ''1'', strict type-checking mode is used for operators in the the file. If ''0'', weak type-checking mode is used.

Similar to ''declare(strict_types=1)'', ''declare(strict_operators=1)'' directive **must** be the first statement in a file. If it appears anywhere else in the file it will generate a compiler error. Block mode is also explicitly disallowed (''declare(strict_operators=1);'' is the only allowed form). If the file contains both ''declare(strict_types=1)'' and ''declare(strict_operators=1)'', the order of these two directives doesn't matter.

==== Behaviour of strict type checks ====
When strict type checking for operators is enabled, using an operator with an unsupported type will throw a ''TypeError'', rather than cast it to a supported type.

In case an operator can work with several (or all) types, the types on both sides of the operator need to match.

The one exception is that [[http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.2|widening primitive conversion]] is allowed for ''int'' to ''float''. This means that parameters that declare ''float'' can also accept ''int''.

<file php widening.php>
<?php
declare(strict_operators=1);

1.2 + 2; // float(3.2)
</file>

In this case, we're passing an ''int'' to a function that accepts ''float''. The parameter is converted (widened) to float.

No other conversions are allowed.

==== Comparison operators ====
Comparison operators work on all scalar types. The types of both values need to match.

Non-scalar types only support the ''=='', ''==='', ''!='' and ''!=='' operators.

<code php>
"foo" > "bar";  // true
"foo" > 10;     // TypeError("Type mismatch string and int on greater than (>) operator")

"foo" == "bar"; // false
"foo" == 10;    // TypeError("Type mismatch string and int on equals (==) operator")

true > false;   // true
true != 0;      // TypeError("Type mismatch bool and int on not equals (!=) operator")

[10] > [];      // TypeError("Unsupported type array on greater than (>) operator")
</code>

=== Numeric string comparison ===
Numeric strings are compared the same way as non-numeric strings. To compare two numeric strings as numbers, they need to be cast to floats.

<code php>
"120" > "99.9";               // false
(float)"120" > (float)"99.9"; // true
</code>

Results are similar to [[http://php.net/strcmp|''strcmp'']].

=== Array comparison ===
Comparing two arrays will never throw a ''TypeError''. Non-array values in the array are compared using both type and value, thus similar to the ''==='' operator.

The only difference between using the ''=='' and ''==='' operator is the order of the keys of the array.

<code php>
['a' => 'foo', 'b' => 'bar'] == ['b' => 'bar', 'a' => 'foo'];  // true
['a' => 'foo', 'b' => 'bar'] === ['b' => 'bar', 'a' => 'foo']; // false

['a' => 'foo', 'b' => 'bar'] == ['b' => 'bar', 'a' => 0];      // false (no type casting)
</code>

=== Object comparison ===
Comparing two objects of different classes using the ''=='' or ''!='' operator will throw a ''TypeError''.

<code php>
class Foo {
  public $x;
  
  public function __construct($x) {
    $this->x = $x;
  }
}

class FooBar extends Foo {}

(new Foo(10)) == (new Foo(10));     // true
(new Foo(10)) == (new Foo(99));     // false
(new Foo(10)) === (new Foo(10));    // false

(new Foo(10)) == (new FooBar(11));  // TypeError("Type mismatch Foo object and FooBar object on equals (==) operator")
(new Foo(10)) === (new FooBar(11)); // false
</code>

Comparing two objects of the same class will with these operators checks the properties of the objects. By default, properties are compared in a similar fashion to the ''==='' operator. If the property of both objects contains arrays or objects of the same class, they're compared as using the ''=='' operator.

==== Arithmetic and Incrementing operators ====
Arithmetic and incrementing/decrementing operators will only work with integers floats. Using values of any other type will result in a ''TypeError''.

The ''+'' operator is still available for arrays as union operator, requiring both values to be arrays.

==== Bitwise Operators ====
Bitwise operators expect both parameters to be an integer. The ''&'', ''|'' and ''^'' operators also accept strings as operants.

Using strings for ''~'', ''>>'' or ''<<'', mixing strings with integers or using any other type will throw a ''TypeError''.

==== String Operators ====
The concatenation operator ''.'' will throw a ''TypeError'' if used with any other types than strings. This includes objects that can be cast to a string and integers.

==== Logical Operators ====
//To be discussed//

==== Switch control structure ====
When strict-type checking for operators is enabled, the ''switch'' statement will do a strict comparison, similar to ''===''. It will **never** throw a ''TypeError''.

===== FAQ =====

==== Shouldn't ''=='' and ''!='' always a return a boolean? ====
We could consider letting ''=='' and ''!='' do a type check and always return ''false'' in case the type is different. This would make them work similarly to some other languages like Python. However, PHP already has the ''==='' and ''!=='' operator to accomplish this and thus can use ''=='' and ''!='' for strict type comparision.

Use ''!='' and ''=='' adds the check that you have the expected types and you don't get an unexpected (silent) ''false'' on statements like ''10 == "10"''.

==== Why can't string operators cast values to a string? ====
Casting values like an integer to a string is pretty harmless and probably the expected behavior. The same could be said for objects with a ''__toString()'' method.

The same argument could be made for functions with a ''string'' type hint. With ''strict_types'' the choice has been made not to do any kind of implicit casting, except for widening primitive conversion from an integer to a float. For consistency, the same logic is followed by this directive.

===== Backward Incompatible Changes =====
None

===== Open Issues =====
    * Logical operators may throw a ''TypeError'' when used with other values than booleans. We see this in strict type languages like Go. However, this behavior can be deemed as unexpected given that ''if ($foo)'' will always work, but ''if ($foo || $bar)'' might throw a type error.
    * Rather than using a new directive, we could also use ''strict_types'' with different values, eg ''declare(strict_types=functions,operators)''.

===== Future Scope =====
The ''strict_operators'' directive may also include the way values are interpreted as boolean in control structures like ''if'' and ''while''. Though in that case, choosing a different name for the directive is probably in order, as it reaches beyond operators.

Array keys like ''$array[12.34]'' also get silently cast to an integer. This might also throw a ''TypeError''. However since it's not an operator, it's not directly in this scope.

===== Unaffected PHP Functionality =====
This RFC

  * does not affect any functionality concerning explicit type casting.
  * does not affect variable casting that occurs in (double-quoted) strings.
  * is largely unaffected by other proposals like [[rfc:string_to_number_comparison|PHP RFC: Saner string to number comparisons]] that focus on improving type juggling at the cost of breaking BC.

===== Proposed Voting Choices =====
Include these so readers know where you are heading and can discuss the proposed voting options.

===== Patches and Tests =====
A patch will be created by my after this RFC has been discussed.

===== Rejected Features =====
