
====== PHP RFC: Return Type-hinting ======
  * Version: 0.1
  * Date: 2014-03-20 
  * Author: Levi Morrison <levim@php.net>
  * Status: Draft
  * First Published at: https://wiki.php.net/rfc/returntypehinting

===== Introduction =====
Many developers would like to be able to declare the type of a return value. The basic idea has been proposed in at least three RFCs and has had a few other discussions (see [[#references]]).

Return type-hinting has several motivators and use-cases:
  * Preventing unintended return types
  * Providing return types on interface implementations((See [[#variance-and-signature-validation|Variance and Signature Validation]] and [[#examples]] for more details on how this works)).
  * Documenting return type information that is not easily invalidated (unlike comments).

//Providing a return type is optional.// This is important so that it does not introduce a backward compatibility break and so that it doesn't force users to use return types if they don't want to. 

===== Proposal =====
This proposal adds an optional return type-hint to all types of function declarations including closures, functions, interface method declarations and class declarations. This RFC does not change or add type-hints (see [[#differences_from_past_rfcs|differences from past RFCs]]).

Simplified example of ''function_declaration_stmt'':

  "function" ["&"] T_STRING "(" parameter_list ")" [":"  (T_STRING | array | callable)] "{"
      inner_statement_list
  "}"

==== Variance and Signature Validation ====
The enforcement of the type-hint during inheritance will be covariant. Covariant return types is considered to be type sound and is used in many other languages((C++, Java and others use covariant return types, just as is proposed here.)). The covariance allows an overrider to declare a return type that is a subclass of the original return type; this is illustrated in the [[#examples]] below.

If a mismatch is detected during compile time (eg a class improperly overriding a return type) then ''E_COMPILE_ERROR'' will be issued. If a type mismatch is detected when the function returns then ''E_RECOVERABLE_ERROR'' will be issued.

A class or interface may add a return type to an inherited method where one did not originally exist. This is show in the examples section in the Iterator example.

==== Position of Type-hint ====
The two major conventions in other programming languages for placing return type information are:

  * Before the function name: <php>return_type function_name(){}</php>
  * After the parameter list: <php>function_name() return_type {}</php>

The former position has been proposed in the past and the RFCs were either declined or withdrawn. One cited issue is that many developers wanted to preserve the ability to search for <php>function foo</php> to be able to find the definition for ''foo''.

The latter position is used in several languages(([[http://hacklang.org/|Hack]],  [[http://www.haskell.org|Haskell]], and [[http://www.erlang.org/|Erlang]] all put the return type after the parameter list)); it is also used in C++11's lambda declarations when the type cannot be deduced.

Declaring the return type after the parameter list will have no known conflicts in the parser.

==== Allowing NULL for Objects ====
Consider the following function: 

<PHP>
function foo(): DateTime { 
    return null; // invalid
}
</PHP>

It declares that it will return ''DateTime'' but returns <php>null</php>; this type of situation is common in many languages including PHP. In this RFC this pattern will not work by design. The idea behind using typed variables in a portion of code is that by putting constraints on variable types it becomes easier to reason about. By allowing <php>null</php> by default means that the programmer would always have to worry about the <php>null</php> case on return values. This works against the reason for introducing the type constraint in the first place.

Instead it is up to the developer to choose whether to allow <php>null</php> or not:

<PHP>
function foo(): ?DateTime { 
    return null; // valid
}
</PHP>

The <php>?</php> marker indicates that the function may return <php>null</php> or the object indicated. This RFC currently restricts the marker to object types only; you cannot use it with <php>callable</php> or <php>array</php>.

==== Examples ====
Here are some examples of valid and invalid uses.

=== Examples of Valid Use ===
<PHP>
// Covariant return-type:

interface Collection {
    function map(callable $fn): Collection;
}

interface Set extends Collection {
    function map(callable $fn): Set;
}
</PHP>
<PHP>
// Overriding a method that did not have a return type:

interface Iterator {
    function rewind();
    function valid();
    function key();
    function current();
    function next();
}

class CommentsIterator implements Iterator {
    function current() : Comment;
}
</PHP>

=== Examples of Invalid Use ===
<PHP>
// return type does not match type-hint
function get_config(): array {
    return null;
}
</PHP>
<PHP>
// invalid type-hint
function answer(): int {
    return 42;
}
</PHP>
<PHP>
// Missing return type on override:

interface UserGateway {
    function find($id) : User; 
}

class UserGateway_MySql implements UserGateway {
    function find($id); // must return User or subtype of User
}
</PHP>
<PHP>
// Defining a return type on a Generator
function filter(Traversable $in, callable $filter): array {
    foreach ($in as $key => $value) {
        yield $filter($key, $value);
    }
} 
</PHP>

==== Multiple Return Types ====
This proposal specifically does not allow multiple return type-hints; adding multiple return types is out of the scope of this RFC and would require a separate RFC if desired. If you want to use multiple return types simply omit a return type declaration and rely on PHP's existing dynamic nature.

==== Differences from Past RFCs ====
This proposal differs from past RFCs in several key ways:

  * //We keep the current type-hint options.// Past proposals have suggested new types such as ''void'', ''int'', ''string'' or ''scalar''.
  * //We allow type-hints on all function types//((Except [[#generators]])). Will Fitch's proposal suggested adding it for methods only.
  *//We keep the current search patterns.// You can still search for <php>function foo</php> to find <php>foo</php>'s definition; all previous RFCs broke this.
  * //We do not modify or add keywords.// Past RFCs have proposed new keywords such as ''nullable'' and more. We still require the <php>function</php> keyword.

===== Other Impact =====

==== On Backward Compatiblity ====
This RFC is backwards compatible with previous PHP releases.

==== On SAPIs ====
There is no impact on any SAPI.

==== On Existing Extensions =====
There is no known impact on extensions.

==== On Performance ====
Until a patch is completed (Joe Watkins has offered to provide one) the impact on performance is unknown.

===== Proposed PHP Version(s) =====
As there are no known BC breaks this RFC targets PHP 5.7. If a BC break is discovered it will be proposed for PHP 6.0.

===== Proposed Voting Choices =====
This RFC modifies the PHP language syntax and therefore requires a two-third majority of votes.

===== Patches and Tests =====
Currently there isn't a patch; Joe Watkins has offered to provide one.

===== References =====
  * [[rfc:typehint|Return value and parameter type hint]] by Felipe; 2008. [[http://marc.info/?l=php-internals&m=120753976214848&w=2|Mail Archive]].
  * [[rfc:returntypehint|Return Type-hint]] by Felipe; 2010. [[http://marc.info/?l=php-internals&m=128036818909738&w=2|Mail Archive]]
  * [[rfc:returntypehint2|Method Return Type-hints]] by Will Fitch; 2011. [[http://marc.info/?t=132443368800001&r=1&w=2|Mail Archive]].

===== Future Work =====
  * Reflection support
  * Consider allowing extensions to define type-hints for return values.