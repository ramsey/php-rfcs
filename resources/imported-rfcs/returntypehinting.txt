
====== PHP RFC: Return Type Declarations ======
  * Version: 0.1
  * Date: 2014-03-20 
  * Author: Levi Morrison <levim@php.net>
  * Status: Draft
  * First Published at: https://wiki.php.net/rfc/returntypehinting

===== Introduction =====
Many developers would like to be able to declare the return type of a function. The basic idea has been proposed in at least three RFCs and has had a few other discussions (see [[#references]]).

Declaring return types has several motivators and use-cases:
  * Preventing unintended return types
  * Providing return types on interface implementations((See [[#variance-and-signature-validation|Variance and Signature Validation]] and [[#examples]] for more details on how this works)).
  * Documenting return type information that is not easily invalidated (unlike comments).

//Providing a return type is optional.// This is important so that it does not break compatibility with older versions and so that it doesn't force users to use return types if they don't want to. 

===== Proposal =====
This proposal adds an optional return type declaration to function declarations including closures, functions, generators, interface method declarations and class declarations. This RFC does not change the existing type declarations nor does it add new ones (see [[#differences_from_past_rfcs|differences from past RFCs]]).

Example of ''function_declaration_stmt'':

  "function" ["&"] T_STRING "(" parameter_list ")" [":"  (T_STRING | array | callable)] "{"
      inner_statement_list
  "}"

Here is a brief example of the syntax in action:
<PHP>
function foo(): array {
    return [];
}
</PHP>
More examples can be found in the [[#examples|Examples]] section.

==== Variance and Signature Validation ====
The enforcement of the declared return type during inheritance will be covariant; this allows an over-riding method to declare a return type that is a sub-type of the original (illustrated in [[#examples]]). Additionally, a class or interface may add a return type to an inherited method where one did not originally exist (also shown in examples).

If a mismatch is detected during compile time (e.g. a class improperly overriding a return type) then ''E_COMPILE_ERROR'' will be issued. If a type mismatch is detected when the function returns then ''E_RECOVERABLE_ERROR'' will be issued.

Covariant return types are considered to be type sound and are used in many other languages((C++, Java and others use covariant return types, just as is proposed here.)).

==== Position of Type Declaration ====
The two major conventions in other programming languages for placing return type information are:

  * Before the function name: <php>return_type function_name();</php>
  * After the parameter list: <php>function_name() return_type;</php>

The former position has been proposed in the past and the RFCs were either declined or withdrawn. One cited issue is that many developers wanted to preserve the ability to search for <php>function foo</php> to be able to find the definition for ''foo''.

The latter position is used in several languages(([[http://hacklang.org/|Hack]],  [[http://www.haskell.org|Haskell]], and [[http://www.erlang.org/|Erlang]] all put the return type after the parameter list)); it is also used in C++11's lambda declarations when the type cannot be inferred by the compiler. 

Declaring the return type after the parameter list has no conflicts in the parser.

==== Returning by Reference ====

This RFC does not change the location of ''&'' when returning by reference. The following examples are valid:
<PHP>
function &array_sort(array &$data) {
    return $data;
}

function &array_sort(array &$data): array {
    return $data;
}
</PHP>

==== Disallowing NULL on Return Types ====
Consider the following function: 

<PHP>
function foo(): DateTime { 
    return null; // invalid
}
</PHP>

It declares that it will return ''DateTime'' but returns ''null''; this type of situation is common in many languages including PHP. By design this RFC does not allow ''null'' to be returned in this situation for two reasons:

  - This aligns with current type behavior which does not allow ''null'' to be passed, except when a ''null'' default is also declared.
  - Allowing ''null'' by default works against the purpose of type declarations. Type declarations make it easier to reason about the surrounding code. If ''null'' was allowed the programmer would always have to worry about the ''null'' case.

The [[rfc:nullable_typehints|Nullable Type-Hints RFC]] addresses this shortcoming and more.

==== Examples ====
Here are some snippets of both valid and invalid usage.

=== Examples of Valid Use ===
<PHP>
// Covariant return-type:

interface Collection {
    function map(callable $fn): Collection;
}

interface Set extends Collection {
    function map(callable $fn): Set;
}
</PHP>
<PHP>
// Overriding a method that did not have a return type:
interface Comment {}
interface CommentsIterator extends Iterator {
    function current(): Comment;
}
</PHP>
<PHP>
// Using a generator:

interface Collection extends IteratorAggregate {
    function getIterator(): Iterator;
}

class SomeCollection implements Collection {
    function getIterator(): Iterator {
        foreach ($this->data as $key => $value) {
            yield $key => $value;
        }
    }
}
</PHP>

=== Examples of Invalid Use ===

The error messages are taken from the current patch.

----
<PHP>
// Returned type does not match the type declaration

function get_config(): array {
    return 42;
}
</PHP>
''Fatal error: the function get_config was expected to return an array and returned an integer in %s on line %d''

----

<PHP>
// Int is not a valid type declaration

function answer(): int {
    return 42;
}
</PHP>
''Fatal error: the function answer was expected to return an object of class int and returned an integer in %s on line %d''

----

<PHP>
// Cannot return null with a return type declaration

function foo(): bar {
    return null;
}
</PHP>
''Fatal error: the function foo was expected to return an object of class bar and returned null in %s on line %d''

----

<PHP>
// Missing return type on override

class User {}

interface UserGateway {
    function find($id) : User; 
}

class UserGateway_MySql implements UserGateway {
    // must return User or subtype of User
    function find($id) {
        return new User();
    }
}
</PHP>
''Fatal error: Declaration of UserGateway_MySql::find should be compatible with UserGateway::find($id) : User, return type missing in %s on line %d''

----

<PHP>
// Cannot yield non-object, compile time check

function foo(): array {
    yield [];
}
</PHP>
''Fatal error: Generators may only yield objects, array is not a valid type in %s on line %d''


==== Multiple Return Types ====
This proposal specifically does not allow declaring multiple return types; this is out of the scope of this RFC and would require a separate RFC if desired.

If you want to use multiple return types, simply omit a return type declaration and rely on PHP's excellent dynamic nature.

==== Reflection ====

Reflection support for return types was designed after the existing parameter type methods. The class ''ReflectionFunctionAbstract'' has two new methods:

  - ''hasReturnType'' - returns bool
  - ''getReturnType'' - returns ReflectionClass or string (''array'', ''callable'')

<PHP>
$functions = [
    function() : stdClass {return new stdClass;},
    function() : array { return []; },
    function() : callable { return $this; },
    function() {}
];

foreach ($functions as $function) {
    $reflector = new ReflectionFunction($function);
    var_dump(
        $reflector->hasReturnType(),
        $reflector->getReturnType()
    );
}
</PHP>

<code>
bool(true)
object(ReflectionClass)#6 (1) {
  ["name"]=>
  string(8) "stdClass"
}
bool(true)
string(5) "array"
bool(true)
string(8) "callable"
bool(false)
NULL
</code>

==== Differences from Past RFCs ====
This proposal differs from past RFCs in several key ways:

  * **We keep the current type options.** Past proposals have suggested new types such as ''void'', ''int'', ''string'' or ''scalar''.
  * **We allow return type declarations on all function types**. Will Fitch's proposal suggested adding it for methods only.
  * **We keep the current search patterns.** You can still search for <php>function foo</php> to find <php>foo</php>'s definition; all previous RFCs broke this.
  * **We do not modify or add keywords.** Past RFCs have proposed new keywords such as ''nullable'' and more. We still require the <php>function</php> keyword.

===== Other Impact =====

==== On Backward Compatiblity ====
This RFC is backwards compatible with previous PHP releases.

==== On SAPIs ====
There is no impact on any SAPI.

==== On Existing Extensions =====
The structs ''zend_function'' and ''zend_op_array'' have been changed; extensions that work directly with these structs may be impacted.

==== On Performance ====
The impact of this RFC on performance is still unknown; performance testing will be done before voting phase.

===== Proposed PHP Version(s) =====
This RFC targets PHP 5.7 or PHP 6.0, whichever comes first.

===== Proposed Voting Choices =====
This RFC modifies the PHP language syntax and therefore requires a two-third majority of votes.

===== Patches and Tests =====
Joe Watkins has provided [[https://github.com/krakjoe/php-src/compare/returntypehinting|an implementation]] which includes tests, reflection and opcache support. Any feedback is welcome and appreciated.

===== References =====
  * [[rfc:returntypehint2|Method Return Type-hints]] by Will Fitch; 2011. [[http://marc.info/?t=132443368800001&r=1&w=2|Mail Archive]].
  * [[rfc:returntypehint|Return Type-hint]] by Felipe; 2010. [[http://marc.info/?l=php-internals&m=128036818909738&w=2|Mail Archive]]
  * [[rfc:typehint|Return value and parameter type hint]] by Felipe; 2008. [[http://marc.info/?l=php-internals&m=120753976214848&w=2|Mail Archive]].
  * [[http://derickrethans.nl/files/meeting-notes.html#type-hinted-properties-and-return-values|Type-hinted properties and return values]] from meeting notes in Paris; Nov 2005.

In the meeting in Paris on November 2005 it was decided that PHP should have return type declarations and some suggestions were made for syntax. Suggestion 5 is nearly compatible with this RFC; however, it requires the addition of a new keyword ''T_RETURNS''. This RFC opted for a syntax that does not require additional tokens so ''returns'' was replaced by '':''.

The following (tiny) patch would allow the syntax in suggestion 5 to be used alongside the current syntax. This RFC does not propose that both versions of syntax should be used; the patch just shows how similar this RFC is to that suggestion from 2005.

https://gist.github.com/krakjoe/f54f6ba37e3eeab5f705

===== Related Work =====

Allowing null to be returned in a type hint (such as <php>?DateTime</php>) is discussed in a related RFC: [[rfc:nullable_typehints|Declaring Nullable Types]]

===== Future Work =====

Ideas for future work include:

  * Allowing functions to declare that they do not return anything at all (''void'')
  * Unifying the reflection type API by introducing a ''ReflectionType'' class that both parameter and return types can use.
