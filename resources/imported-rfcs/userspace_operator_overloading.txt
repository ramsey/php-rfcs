====== PHP RFC: Userspace operator overloading ======
  * Version: 0.1
  * Date: 2020-02-01
  * Author: Jan BÃ¶hmer, jan.h.boehmer@gmx.de
  * Status: Draft
  * First Published at: http://wiki.php.net/rfc/userspace_operator_overloading
===== Introduction =====
At the moment expressions like ''$a + $b'' or ''$a*2'' are only valid if ''$a'' and ''$b'' are scalar types like int or float. However, in many other programming languages like Python, C# or C++ it is possible to overload these operators to use them on classes, to implement custom math (and other) objects. This RFC proposes userspace operator overloading for PHP.

Using objects to represent money values and arbitrary precision numbers or create mathematical objects like complex numbers and vectors is quite common. With this proposal operations with these objects could be written in the more natural and intuitive way of
<PHP>
$result = $a * ($b + $c * $d);
</PHP>
instead of the currently function based method
<PHP>
$a->multiply($b->add($c->multiply($d));
</PHP>

PHP has already an internal mechanism for operator overloading using the ''do_operation'' object handler, which is used for example by GMP and FFI data objects. However, this mechanism is only available for internal PHP objects and currently can not be used for classes created inside PHP.

This RFC only proposes overloading for arithmetic and concatenation operators. Comparison and equality operators are handled differently internally and logic is more complex, so these should be handled in a different RFC.

===== Proposal =====
==== Syntax ====
Operator overloading is done by static magic functions per operator in a class. These functions receive both operands and must return a non null value:
<PHP>
public class Vector3()
{
    public static function __add($lhs, $rhs) {
        // Do something with the values and return an error. If operands types are not supported throw an exception
        // ...
    }
    
    public static function __mul($lhs, $rhs) {
        // ...
    }
}

$a = new Vector3();
$b = new Vector3();

// Equivalent to $x = Vector3::__add($a, $b)
$x = $a + $b;
//Equivalent to $y = Vecotr3::__mul(2, $b)
$y = 3 * $b;
</PHP>

By passing both operands to the handler, it can decide between the cases on non-commutative operators (''$a / 2'' vs. ''2 / $a''), which would be more difficult when only the "other" operand (besides ''$this'') is passed.

The magic function can accept any type, the function has to decide if it can handle the type (and the value). If it can not handle the given type, it has to throw an exception. 

==== Overloadable Operators ====
Like mentioned above only basic arithmetic operators should be overloadable, not compare or equality operators. The operators which are allowed to be overloaded and their associated magic functions are:

|                 ^ Operator      ^ Magic function     ^
^ Addition        | ''+''         | %%__add%%          |
^ Subtraction     | ''-''         | %%__sub%%          |
^ Multiplication  | ''*''         | %%__mul%%          |
^ Division        | ''/''         | %%__div%%          |
^ Power           | ''**''        | %%__pow%%          |
^ Modulo          | ''.''         | %%__mod%%          |
^ Concatenation   | ''.''         | %%__concat%%       |
^ Bitwise shift left   | ''<<''         | %%__sl%%       |
^ Bitwise shift right   | ''>>''         | %%__sr%%       |
^ Bitwise OR   | ''%%|%%''         | %%__or%%       |
^ Bitwise AND   | ''&''         | %%__and%%       |
^ Bitwise XOR   | ''^''         | %%__xor%%       |
^ Bitwise NOT   | ''~''         | %%__not%%       |

''- $a'' is interpreted as ''-1 * $a''. 

The shorthand assignment operators follow the normal logic, that ''$a += $b'' is the same as ''$a = $a + $b'' and therefore can not be overloaded on their own.

The same applies for increment/decrement. These are treat as ''$a + 1'' respectively ''$a - 1''. If the class can not handle addition with an integer, the class has to throw an exception. 

==== Evaluation order ====
The overloaded operators follow the normal operator precedence (e.g. * is evaluated before +). Brackets can be used to control the evaluation order in the way it possible for scalar operands.

If an object is encountered as one of the operands, it tried to call the magic function on the left object. If the left operand is not an object or its class does not overload the operator, the magic function is called on the right operand.

<PHP>
$test = $a + $b;
//First ClassA::__add($a, $b) is called
//If not possible ClassB::__add($a, $b) is called
</PHP>

==== Error handling ====
If an operator is used with an object that does not overload this operator, an NOTE is trigged, which gives the user a hint about the method that has to be overloaded. For backward compatibility objects, which do not overload the operator, are converted to integer 1 (current behavior).

If the class overloads the operator, and the magic method do not return a value or return null, an ERROR is triggered,

==== Other ====
A user who overloads a operator MUST ensure, that the magic function do not change the existing operand objects, or it will cause undesirable behavior. In the moment there is no way to enforce immutability on objects, so the user is responsible. The documentation should include a warning about this.



===== Backward Incompatible Changes =====
There are no backwards incompatible changes.

As long as the user does not implement, the operator magic functions, operators on objects will behave in the previous way.

===== Proposed PHP Version(s) =====
PHP8

===== RFC Impact =====
==== To SAPIs ====
None.

==== To Existing Extensions ====
None. Extensions can override the ''do_operation'' object handler for their own classes like before.

==== To Opcache ====
None.

==== New Constants ====
None.

==== php.ini Defaults ====
None.

===== Future Scope =====
The following things are related to operator overloading but are **not** part of this RFC:
==== Comparison operators ====
The comparison operators (like ''<'', ''>'', ''=='', etc.) can not be overloaded in the way discussed in this RFC. For custom object comparison an interface (like proposed in this [[rfc:comparable|old RFC]]) could be useful. Some objects can not be really compared (in the way greater/lesser than the other), but only decided on if they are equal. For these cases an ''Equatable'' Interface (with an ''equalTo()'' function) could be useful.

==== Immutable types ====
To ensure that objects can not be changed (which could cause undesirable behavior), immutable objects (see this [rfc:immutability|old RFC]] could be helpful.

===== Proposed Voting Choices =====
Accept the existing proposed changes for 8.0: yes/no

===== Patches and Tests =====

===== References =====
   * [[https://externals.io/message/108300|First email discussion]]
   * [[rfc:operator-overloading|Old RFC with an similar propose]]

===== Rejected Features =====