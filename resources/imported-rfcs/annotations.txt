====== Request for Comments: Class Metadata ======
  * Version: 1.0
  * Date: 2010-05-26
  * Author: Guilherme Blanco <guilhermeblanco@hotmail.com>
  * Status: Ready for discussion
  * First Published at: http://wiki.php.net/rfc/annotations


===== Introduction =====

Many languages currently support metadata information. This RFC exposes an idea about how can it be implemented in PHP, providing a powerful tool that many applications can take advantage of.

==== Why do we need Class Metadata? ====

Frameworks in general rely on metadata information in order to correctly work. They can use it for many purposes:

  * **phpUnit** Providing meta functionality for test cases, examples: @dataProvider for test data iteration, @expectedException for catching exceptions, etc.
  * **phpDoc** Providing useful information for API generation, examples: @author, @param, @return, etc.
  * **Doctrine** For Object-Relational mapping, examples: @Entity, @OneToOne, @Id, etc.
  * **Zend Framework Server classes** Used to automate mappings for XML-RPC, SOAP, etc.
  * **Others** One clear thing that comes to my mind is Validation, Functional Behavior injection (which could take advantage of [[rfc:Traits]]), etc. Also, any Framework could take advantage of it somehow.

So, any meta mapping injection could be easily achieved via the implementation of a centralized Annotations support.

===== Common Misconceptions =====

Metadata mapping is commonly referred an feature that cannot be used widely, so its implementation is useless.
As pointed previously, there're many use cases for this support.

===== Proposal =====

First thing to be decided would be the tokens to be used for categorize an Annotation.

  * Java uses [[http://en.wikipedia.org/wiki/Java_annotation|Annotations]]
  * C# uses [[http://en.wikipedia.org/wiki/.NET_metadata|Attributes]]

When using meta mapping, less characters is preferred to speed up its construction.

Doctrine defines a generic package that can be used: [[http://github.com/doctrine/common/tree/master/lib/Doctrine/Common/Annotations]]
There it is possible to extract this EBNF:

<code>
Annotations     ::= Annotation {Annotation}*
Annotation      ::= "@" AnnotationName ["(" [Values] ")"]
AnnotationName  ::= QualifiedName | SimpleName | AliasedName
QualifiedName   ::= NameSpacePart "\" {NameSpacePart "\"}* SimpleName
AliasedName     ::= Alias ":" SimpleName
NameSpacePart   ::= identifier
SimpleName      ::= identifier
Alias           ::= identifier
Values          ::= Array | Value {"," Value}*
Value           ::= PlainValue | FieldAssignment
PlainValue      ::= integer | string | float | boolean | Array | Annotation
FieldAssignment ::= FieldName "=" PlainValue
FieldName       ::= identifier
Array           ::= "{" ArrayEntry {"," ArrayEntry}* "}"
ArrayEntry      ::= Value | KeyValuePair
KeyValuePair    ::= Key "=" PlainValue
Key             ::= string | integer
</code>

With identifier being the terminal: [a-zA-Z_][a-zA-Z0-9\-_]*

We have the limitation of characters that can have double meaning (one good example could be @, which would conflict with error suppressing when meta mapping a class definition).
So we need to bring a list of tokens that could be used. I imported the suggestions from [[rfc:namespaceseparator|Namespace separator]] discussion:

<code>**</code> 
<code>^^</code>
<code>%%</code>
<code>:> </code>
<code>:)</code>
<code>:::</code>

We can even consider a composition of tokens, example using [...] as attribute delimiter:

<code>
[Entity(tableName="users")]
class User
{
    [Column(type="integer")]
    [Id]
    [GeneratedValue(strategy="AUTO")]
    protected $id;

    // ...

    [ManyToMany(targetEntity="Phonenumber")]
    [JoinTable(
        name="users_phonenumbers",
        joinColumns={
            [JoinColumn(name="user_id", referencedColumnName="id")]
        },
        inverseJoinColumns={
            [JoinColumn(name="phonenumber_id", referencedColumnName="id", unique=true)]
        }
    )]
    protected $Phonenumbers;
}
</code>


The support would exist via the inclusion of a ReflectionAttribute object.
This would populate the item for each correspondent Reflection* instance. Affected classes would be ReflectionClass, ReflectionProperty and ReflectionMethod.
This is the interface prototype each of these classes should implement in order to support it:

<code php>
interface \ReflectionAttributeSupport
{
    /**
     * Retrieve a ReflectionAttribute instance attached to the Reflection*.
     *
     * @param string $attribute Attribute to be checked for.
     * @return \ReflectionAttribute Related ReflectionAttribute if found; null if not found.
     */
    public function getAttribute($attribute);
}
</code>

Finally, this is he interface prototype of a ReflectionAttribute:

<code php>
interface \ReflectionAttribute implements \ArrayAccess
{
    /**
     * Returns the first index of values (equivalent to $reflAttr[$field]).
     * This is intentional to support this EBNF grammar rules:
     *
     *     Values ::= Array | Value {"," Value}*
     * 
     * Calling it should return the Array (which is converted to PHP array) 
     * or the found Value (which is a ReflectionAttribute, any other object 
     * instance, array or a scalar value).
     *
     * In the case of a Value that is a FieldAssignment and the key is not
     * found, it should throw a \RuntimeException.
     *
     * @param mixed $field Value key to be fetched. Optional with default to
     *                     the first index of an array.
     * @return mixed
     * @throws \RuntimeException
     */
    public function getValue($field = 0);
}
</code>

Of course this is not highly engineered and can be easily managed to a better implementation. This is just a draft that can be discussed and changed as needed to meet new requirements.


===== Changelog =====

2010-05-26 guilhermeblanco Initial RFC creation.