====== PHP RFC: final class Deque ======
  * Version: 0.1
  * Date: 2021-09-16
  * Author: Tyson Andre, tandre@php.net
  * Status: Draft
  * Implementation: https://github.com/php/php-src/pull/7500
  * First Published at: http://wiki.php.net/rfc/deque

===== Introduction =====

PHP's native ''array'' type is rare among programming language in that it is used as an associative map of values, but also needs to support lists of values.
In order to support both use cases, additional memory is needed to track keys ([[https://www.npopov.com/2014/12/22/PHPs-new-hashtable-implementation.html|around twice as much as is needed to just store the values]], for non-reference counted values) .

Additionally, while it is possible to efficiently remove elements from the start of an ''array'' (in terms of insertion order), it is very inefficient to prepend elements to the start of a large ''array'' due to needing to either copy the array or move all elements in the internal array representation.

While ''SplDoublyLinkedList'' and its subclass ''SplQueue''/''SplStack'' exists, it has several drawbacks:

    - ''SplDoublyLinkedList'' is internally represented by a doubly linked list, making it use roughly twice as much memory as the proposed ''Deque''
    - ''push''/''pop''/''unshift''/''shift'' from ''SplDoublyLinkedList'' are slower due to needing to allocate or free the linked list nodes.
    - Reading values in the middle of the ''SplDoublyLinkedList'' is proportional to the length of the list, due to needing to traverse the linked list nodes.
    - Iteration behavior cannot be understood without knowing what constructed the ''SplDoublyLinked'' instance or set the flags.

It would be useful to have an efficient Deque container in the standard library for the following reasons: 

    - To save memory in applications or libraries that may need to store many lists of values or run for long periods of time. Notably, PHP's ''array'' type will never release allocated capacity - see https://www.npopov.com/2014/12/22/PHPs-new-hashtable-implementation.html
    - To provide a better alternative to ''SplDoublyLinkedList'' for use cases that require variable sized collections (For lists of values) that can be passed by value to be modified.
    - As a more efficient option than ''array'' and ''SplDoublyLinkedList'' as a queue or ''Deque'', especially for ''unshift''


===== Proposal =====
This proposes to add the class ''final class Deque'' to PHP.

Similarly to deques in other languages, this is backed by a memory-efficient representation with good cache locality and provides constant amortized-time push/pop/shift/unshift operations. (this implementation is a circular buffer represented as a raw C array of values with a size, offset, and capacity)

This reclaims memory that is no longer used  (when less than a quarter of the capacity is used), unlike ''array''

Similarly to ''ArrayObject'' and ''SplDoublyLinkedList'', the ''$x[] = $value'' shorthand for appending to the ''Deque'' is supported in addition to ''ArrayAccess'' functionality.

The proposed API is:

<code php>
/**
 * A double-ended queue represented internally as a circular buffer.
 * This has much lower memory usage than SplDoublyLinkedList or its subclasses (SplStack, SplStack),
 * and operations are significantly faster than SplDoublyLinkedList.
 *
 * This supports amortized constant time pushing and popping onto the front or back of the array.
 *
 * Naming is based on https://www.php.net/spldoublylinkedlist
 * and on array_push/pop/unshift/shift.
 */
final class Deque implements IteratorAggregate, Countable, JsonSerializable, ArrayAccess
{
    /** Construct the Deque from the values of the Traversable/array, ignoring keys */
    public function __construct(iterable $iterator = []) {}
    /**
     * The final version of getIterator will iterate over a copy of the Deque's values taken at the time getIterator was called.
     * The iteration keys will be the offsets of the copy(0, 1, ...), and the values will be the values from front to back.
     *
     * i.e. `foreach($deque as $k => $v)` and `foreach($deque->toArray() as $k => $v)` will iterate over the same elements.
     *
     * This will be done to avoid surprises in case pushFront/popFront/clear are called.
     *
     * To access the current version of the Deque without making a copy,
     * use `for ($i = 0; $i < count($deque); $i++) { process($deque[$i]); }`.
     */
    public function getIterator(): InternalIterator {}
    /** Returns the number of elements in the Deque. */
    public function count(): int {}
    /** Returns true if there are 0 elements in the Deque. */
    public function isEmpty(): bool {}
    /** Removes all elements from the Deque. */
    public function clear(): void {}

    public function __serialize(): array {}
    public function __unserialize(array $data): void {}
    /** Construct the Deque from the values of the array, ignoring keys */
    public static function __set_state(array $array): Deque {}

    /** Appends a value to the end of the Deque. */
    public function push(mixed $value): void {}
    /** Prepends a value to the start of the Deque. */
    public function unshift(mixed $value): void {}
    /** Pops a value from the end of the Deque. */
    public function pop(): mixed {}
    /** Shifts a value from the front of the Deque. */
    public function shift(): mixed {}

    /** Peeks at the value at the start of the Deque, throws if empty */
    public function bottom(): mixed {}
    /** Peeks at the value at the end of the Deque, throws if empty */
    public function top(): mixed {}

    /** Returns a list of the elements from front to back. */
    public function toArray(): array {}
    /* Get and set are strictly typed, unlike offsetGet/offsetSet. */
    public function get(int $offset): mixed {}
    public function set(int $offset, mixed $value): void {}
    // Must be mixed for compatibility with ArrayAccess
    public function offsetGet(mixed $offset): mixed {}
    public function offsetExists(mixed $offset): bool {}
    public function offsetSet(mixed $offset, mixed $value): void {}
    /** Throws unconditionally */
    public function offsetUnset(mixed $offset): void {}

    /** This is JSON serialized as a JSON array with elements from front to back */
    public function jsonSerialize(): array {}
}
</code>
 
===== Arguments for using this =====

==== What applications would benefit from Deque? ====

    - **Composer**: https://github.com/composer/composer/blob/2.1.8/src/Composer/DependencyResolver/RuleSetGenerator.php#L157-L203 uses a ''SplQueue'' internally as a work queue in its dependency resolution logic.
    - **Event-Driven frameworks**: https://github.com/reactphp/event-loop/blob/v1.2.0/src/Tick/FutureTickQueue.php uses ''SplQueue'' internally to hold callback functions to call later.
    - **Networking code**: [[https://github.com/predis/predis|Predis]], a userland client for the Redis database, currently uses SplQueue to build a pipeline of commands and associate pipelined outgoing requests with their incoming responses. https://github.com/predis/predis/blob/v1.1.7/src/Pipeline/Pipeline.php#L121-L150

They would benefit from the improved performance that ''SplQueue'' has over ''SplDoublyLinkedList''.

Looking at the [[#benchmarks]] section, ''SplQueue''(and the parent class ''SplDoublyLinkedList'') is typically slower than ''array'' (at the cost of memory). By introducing a data structure ''Deque'' that's even faster and more memory usage than an ''array'' for use as a double-ended queue, even more applications would benefit from it.

    * Additionally, ''Deque'' would allow some code to be refactored or written in a cleaner way in cases where php developers would previously be avoiding using ''SplDoublyLinkedList'' (or ''SplStack''/''SplQueue'') due to its time and memory usage inefficiencies.

As mentioned in [[https://en.wikipedia.org/wiki/Queue_(abstract_data_type)]]

<blockquote>
Queues provide services in computer science, transport, and operations research where various entities such as data, objects, persons, or events are stored and held to be processed later. In these contexts, the queue performs the function of a [[https://en.wikipedia.org/wiki/Buffer_(computer_science)|buffer]]. Another usage of queues is in the implementation of [[https://en.wikipedia.org/wiki/Breadth-first_search|breadth-first search]].
</blockquote>

https://www.php.net/manual/en/class.splqueue.php#116422 is another example

<blockquote>
You can use shift/unshift and push/pop to dequeue/undequeue and queue/unqueue respectively. Really handy for those applications that use sockets where you might not know you can't send data until you attempt to.

for example, this is a function for an application that will un-dequeue the remainder of the data if socket_write indicated it did not write the entire contents of the provided data.
</blockquote>

Even users that don't write code using ''Deque'' may still benefit from its inclusion, due to improved performance and reduced memory usage in the applications and libraries that do adopt it.

==== Why use this instead of SplDoublyLinkedList? ====

    - Pushing/popping/shifting/unshifting takes roughly 30% less time.
    - ''Deque'' typically uses less memory than ''SplDoublyLinkedList''.
    - The iteration order is predictable, unlike ''SplDoublyLinkedList'', where it can be modified with flags
    - Constant-time access for reading or modifying elements at any position in the ''Deque'', unlike ''SplDoublyLinkedList'' where that would require walking the linked list.

==== Why use this instead of array? ====

    - Faster than using array for queue-like workloads (e.g. around 13%-37% less time to add to the end and remove from the front depending on ''Deque'' size and access pattern)
    - It is impossible to prepend to an ''array'' (i.e. to be first in insertion order) in constant time. ''array_unshift'' takes time proportional to the length of an array.
    - ''Deque'' uses much less memory than an ''array'' when used as a queue, especially since that will eventually convert an array to an associative array. See https://www.npopov.com/2014/12/22/PHPs-new-hashtable-implementation.html and benchmarks

===== Usage =====

Examples of how each of these methods in ''Deque'' can be used can be found at https://www.php.net/spldoublylinkedlist - in most cases this can be used as a substitute for ''SplDoublyLinkedList''.

See [[#implementation|Implementation]] for the public API of ''Deque''.
 
===== Implementation Choices =====

==== Global Namespace ====

This maintains consistency with the namespace used for general-purpose collections already in the SPL (as well as relatively recent additions such as ''WeakReference'' and ''WeakMap''). Other recent additions to PHP such as ''ReflectionIntersectionType'' in PHP 8.1 have also continued to use the global namespace when adding classes with functionality related to other classes.

==== Lack of Name Prefix ====

    - Short names are more convenient to remember/use.
    - Possible future additions such as a ''Queue''/''Stack'' based on a efficient C array representation rather than a linked list would conflict with existing Spl names such as ''SplQueue'', ''SplStack'', etc.
    - There is already an addition to the spl without a prefix - ''ArrayObject''. Because ''array'' was already a type its name could not reasonably be any shorter.
    - Functionality has been historically moved from the ''spl'' to core in the past, e.g. ''Iterator'' started out in ''spl''.
    - New generic data structures that are always enabled have not had the ''Spl'' prefix, e.g. https://www.php.net/WeakMap is a recent addition that is final and not prefixed.

==== Accepting an iterable ====

This accepts the values of the iterable in the order of iteration. Keys of the ''iterable'' are ignored (Because this is meant to be a double-ended queue, adding placeholders would not make sense if there were gaps in the array.)

End users may be surprised if integer keys are not the same as the ones passed in by default (e.g. if keys were unset or inserted out of order), which is why ''$preserve_keys = true'' is the default.

==== Final Class ====

If this were extensible, this would have the following drawbacks

    - Not have as strong guarantees to readers of code (or even opcache, if optimizations were added targeting opcache) that elements were actually a vector or that certain methods would/wouldn't throw certain exceptions, or that iteration would be possible.
    - Require more memory and runtime checks to check if this was the original class or a subclass when fetching a value
    - [[https://bugs.php.net/search.php?search_for=SplFixedArray&boolean=0&limit=30&order_by=&direction=DESC&cmd=display&status=All&bug_type=All&project=All&php_os=&phpver=&cve_id=&assign=&author_email=&bug_age=0&bug_updated=0&commented_by=|Be more likely to have discovered or undiscovered bugs]] due to userland extensions of ''Deque''

==== push/pop/shift/unshift (and top()/bottom()) ====

This is consistent with the name used for ''array_push()''/''array_pop()''/''array_shift()''/''array_unshift()'', as well as names used for ''SplDoublyLinkedList''

===== Backward Incompatible Changes =====
The class name ''\Deque'' is now used by PHP, and it will be a compilation error to declare classlikes of the same name in the global namespace since the class already exists.

===== Proposed PHP Version(s) =====
8.2

===== RFC Impact =====
==== To Opcache ====
None

===== Unaffected PHP Functionality =====
PHP's type system remains unchanged (e.g. ''array'') - ''final class Deque'' is a class and instances are ordinary objects.

===== Benchmarks =====

==== Two cycles of appending n values then shifting them from the front ====

Note that it is possible to have constant time removal from the front of a PHP ''array'' efficiently (as long as ''key'' stays at the front of the array), but it is not possible to have constant time prepending (`unshift`) to the front of an array. ''array_unshift'' is a linear time operation (takes time proportional to the current array size).
So ''unshift'' is not included in these benchmarks.

Because there's a second cycle in this benchmark, array becomes an associative array and uses more memory than a packed array (https://www.npopov.com/2014/12/22/PHPs-new-hashtable-implementation.html). (At the time of writing, a packed array uses double the memory of a ''Deque'', though there is an unrelated change in review proposing reducing the memory usage of packed arrays). 

memory_get_usage is not counting the memory overhead of tracking the allocations of a lot of small objects, so the memory usage of ''SplDoublyLinkedList'' is under-reported. ''SplQueue'' is a subclass of ''SplDoublyLinkedList'' and I expect it would have the same performance.

''Deque'' and ''array'' both always capacities that are powers of 2. This benchmark tests the best-case memory usage for ''Deque'' and ''array''

**''Deque'' is faster than ''SplDoublyLinkedList'' at all sizes, and faster than ''array'' at medium and large sizes. The maximum memory usage is also noticeably lower than both ''array'' and ''SplDoublyLinkedList''**

<code none>
Test creating a collection, then two cycles of push+shift (adding n values to the end of collections then shifting all of them from front of collection)
Results for php 8.2.0-dev debug=false with opcache enabled=true

2x Push then shift from array:               n=       1 iterations= 8000000
=> max memory=     376 bytes, create+destroy time=1.115 shift time = 1.008 total time = 2.123 result=0
2x Push then shift from Deque:               n=       1 iterations= 8000000
=> max memory=     144 bytes, create+destroy time=1.584 shift time = 0.844 total time = 2.428 result=0
2x Push then shift from SplDoublyLinkedList: n=       1 iterations= 8000000
=> max memory=     184 bytes, create+destroy time=2.055 shift time = 0.941 total time = 2.996 result=0

2x Push then shift from array:               n=       4 iterations= 2000000
=> max memory=     376 bytes, create+destroy time=0.413 shift time = 0.681 total time = 1.094 result=24000000
2x Push then shift from Deque:               n=       4 iterations= 2000000
=> max memory=     144 bytes, create+destroy time=0.522 shift time = 0.444 total time = 0.966 result=24000000
2x Push then shift from SplDoublyLinkedList: n=       4 iterations= 2000000
=> max memory=     280 bytes, create+destroy time=1.033 shift time = 0.511 total time = 1.544 result=24000000

2x Push then shift from array:               n=       8 iterations= 1000000
=> max memory=     376 bytes, create+destroy time=0.307 shift time = 0.621 total time = 0.928 result=56000000
2x Push then shift from Deque:               n=       8 iterations= 1000000
=> max memory=     208 bytes, create+destroy time=0.388 shift time = 0.438 total time = 0.825 result=56000000
2x Push then shift from SplDoublyLinkedList: n=       8 iterations= 1000000
=> max memory=     408 bytes, create+destroy time=0.799 shift time = 0.480 total time = 1.278 result=56000000

2x Push then shift from array:               n=    1024 iterations=   20000
=> max memory=   41016 bytes, create+destroy time=0.452 shift time = 1.445 total time = 1.897 result=20951040000
2x Push then shift from Deque:               n=    1024 iterations=   20000
=> max memory=   16464 bytes, create+destroy time=0.408 shift time = 0.803 total time = 1.211 result=20951040000
2x Push then shift from SplDoublyLinkedList: n=    1024 iterations=   20000
=> max memory=   32920 bytes, create+destroy time=1.432 shift time = 0.945 total time = 2.377 result=20951040000

2x Push then shift from array:               n= 1048576 iterations=      20
=> max memory=41943120 bytes, create+destroy time=1.166 shift time = 1.499 total time = 2.665 result=21990211584000
2x Push then shift from Deque:               n= 1048576 iterations=      20
=> max memory=16777320 bytes, create+destroy time=0.830 shift time = 0.912 total time = 1.742 result=21990211584000
2x Push then shift from SplDoublyLinkedList: n= 1048576 iterations=      20
=> max memory=33554584 bytes, create+destroy time=1.627 shift time = 1.081 total time = 2.708 result=21990211584000
</code>

==== Only appending to a Deque and reading elements without removal ====

Note that the proposed ''Deque'' as well as the existing ''SplDoublyLinkedList''/''SplStack'' are expected to perform equally well at shifting to (adding to) or unshifting from(removing from) the front of an array

**For this benchmark, Deque can be created and read from faster than the fastest methods of reading ''SplStack'' or ''SplFixedArray''.**

    * Note that a ''foreach'' is used instead of random access for ''SplStack'' - ''SplStack'' random access time is proportional to the number of linked list nodes that need to be iterated over to read a value.
    * ''SplFixedArray'' would be faster to append to if it had a ''push()'' method, but there isn't one.

Major notes:

    * ''Deque'' and ''SplFixedArray'' use less memory than other available options.
    * ''Deque'' is faster than object data structures currently available in the SPL.
    * ''array'' is always faster at reading data but currently uses more memory.

//(Note that this benchmarks will have to be redone for the time and ''array'' if other proposed optimizations to array succeed)//

<code none>
Results for php 8.2.0-dev debug=false with opcache enabled=true

Appending to array:         n=       1 iterations= 8000000 memory=     376 bytes, create+destroy time=0.599 read time = 0.285 result=0
Appending to Deque:         n=       1 iterations= 8000000 memory=     144 bytes, create+destroy time=0.957 read time = 0.337 result=0
Appending to SplStack:      n=       1 iterations= 8000000 memory=     184 bytes, create+destroy time=1.614 read time = 0.696 result=0
Appending to SplFixedArray: n=       1 iterations= 8000000 memory=      80 bytes, create+destroy time=1.685 read time = 0.392 result=0


Appending to array:         n=       4 iterations= 2000000 memory=     376 bytes, create+destroy time=0.210 read time = 0.108 result=12000000
Appending to Deque:         n=       4 iterations= 2000000 memory=     144 bytes, create+destroy time=0.309 read time = 0.169 result=12000000
Appending to SplStack:      n=       4 iterations= 2000000 memory=     280 bytes, create+destroy time=0.669 read time = 0.283 result=12000000
Appending to SplFixedArray: n=       4 iterations= 2000000 memory=     128 bytes, create+destroy time=1.063 read time = 0.209 result=12000000


Appending to array:         n=       8 iterations= 1000000 memory=     376 bytes, create+destroy time=0.146 read time = 0.079 result=28000000
Appending to Deque:         n=       8 iterations= 1000000 memory=     208 bytes, create+destroy time=0.210 read time = 0.143 result=28000000
Appending to SplStack:      n=       8 iterations= 1000000 memory=     408 bytes, create+destroy time=0.483 read time = 0.224 result=28000000
Appending to SplFixedArray: n=       8 iterations= 1000000 memory=     192 bytes, create+destroy time=0.955 read time = 0.183 result=28000000


Appending to array:         n= 1048576 iterations=      20 memory=33558608 bytes, create+destroy time=0.713 read time = 0.146 result=10995105792000
Appending to Deque:         n= 1048576 iterations=      20 memory=16777320 bytes, create+destroy time=0.454 read time = 0.263 result=10995105792000
Appending to SplStack:      n= 1048576 iterations=      20 memory=33554584 bytes, create+destroy time=0.826 read time = 0.394 result=10995105792000
Appending to SplFixedArray: n= 1048576 iterations=      20 memory=16777304 bytes, create+destroy time=2.369 read time = 0.358 result=10995105792000
</code>
===== Future Scope =====
If ''\Deque'' is added, there would be plenty of time for myself or others to propose additional methods before PHP 8.2's feature freeze (probably in July 2022)

Future additions to https://github.com/TysonAndre/pecl-teds that are general purpose enough may be possible as well.

===== Proposed Voting Choices =====
Yes/No vote, requiring a 2/3 majority

===== References =====

- https://www.npopov.com/2014/12/22/PHPs-new-hashtable-implementation.html
- https://github.com/TysonAndre/pecl-teds (implementations of multiple data structures, including ''Teds\Deque'', based originally on the ''SplFixedArray'' documentation and my past RFCs)

===== Rejected Features =====

==== Why not use php-ds instead? ====

https://externals.io/message/116048#116054

===== Appendix =====

==== Benchmark Source Code ====

=== Benchmarking repeated push and shift operations ===

<code php>
<?php

const PUSH_SHIFT_CYCLES = 2;

function bench_array(int $n, int $iterations) {
    $totalReadTime = 0.0;
    $startTime = hrtime(true);
    $total = 0;
    for ($j = 0; $j < $iterations; $j++) {
        $startMemory = memory_get_usage();
        $values = [];
        for ($times = 0; $times < PUSH_SHIFT_CYCLES; $times++) {
            for ($i = 0; $i < $n; $i++) {
                $values[] = $i;
            }
            $maxMemory = memory_get_usage();
            $startReadTime = hrtime(true);
            while (count($values) > 0) {
                // Pretend we don't know the actual position of the first array key for this simulated benchmark
                // array_shift is not used because it is linear time (to move all other elements)
                // rather than constant time.
                //
                // This approach is simple at the cost of memory - it converts a packed array to a non-packed array
                // NOTE: Adding a call to reset() is not necessary in this case, and would result in worse performance.
                // NOTE: array_key_first results in quadratic performance for this synthetic benchmark.
                // $key = array_key_first($values);
                $key = key($values);
                $total += $values[$key];
                unset($values[$key]);
            }
            $endReadTime = hrtime(true);
            $totalReadTime += $endReadTime - $startReadTime;
        }

        unset($values);
    }
    $endTime = hrtime(true);

    $totalTime = ($endTime - $startTime) / 1000000000;
    $totalReadTimeSeconds = $totalReadTime / 1000000000;
    printf("2x Push then shift from array:               n=%8d iterations=%8d\n=> max memory=%8d bytes, create+destroy time=%.3f shift time = %.3f total time = %.3f result=%d\n",
        $n, $iterations, $maxMemory - $startMemory, $totalTime - $totalReadTimeSeconds, $totalReadTimeSeconds, $totalTime, $total);
}
function bench_deque(int $n, int $iterations) {
    $startTime = hrtime(true);
    $totalReadTime = 0.0;
    $total = 0;
    for ($j = 0; $j < $iterations; $j++) {
        $startMemory = memory_get_usage();
        $values = new Deque();
        for ($times = 0; $times < PUSH_SHIFT_CYCLES; $times++) {
            for ($i = 0; $i < $n; $i++) {
                $values[] = $i;
            }
            $maxMemory = memory_get_usage();

            $startReadTime = hrtime(true);
            while (count($values) > 0) {
                $total += $values->shift();
            }
            $endReadTime = hrtime(true);
            $totalReadTime += $endReadTime - $startReadTime;
        }

        unset($values);
    }
    $endTime = hrtime(true);
    $totalTime = ($endTime - $startTime) / 1000000000;
    $totalReadTimeSeconds = $totalReadTime / 1000000000;
    printf("2x Push then shift from Deque:               n=%8d iterations=%8d\n=> max memory=%8d bytes, create+destroy time=%.3f shift time = %.3f total time = %.3f result=%d\n",
        $n, $iterations, $maxMemory - $startMemory, $totalTime - $totalReadTimeSeconds, $totalReadTimeSeconds, $totalTime, $total);
}
// SplDoublyLinkedList is a linked list that takes more memory than needed.
// Access to values in the middle of the SplDoublyLinkedList is also less efficient.
function bench_spl_dll(int $n, int $iterations) {
    $startTime = hrtime(true);
    $totalReadTime = 0.0;
    $total = 0;
    for ($j = 0; $j < $iterations; $j++) {
        $startMemory = memory_get_usage();
        $values = new SplDoublyLinkedList();
        for ($times = 0; $times < PUSH_SHIFT_CYCLES; $times++) {
            for ($i = 0; $i < $n; $i++) {
                $values->push($i);
            }
            $maxMemory = memory_get_usage();
            $startReadTime = hrtime(true);
            // Random access is linear time in a linked list, so use foreach instead
            while (count($values) > 0) {
                $total += $values->shift();
            }
            $endReadTime = hrtime(true);
            $totalReadTime += $endReadTime - $startReadTime;
        }
        unset($values);
    }
    $endTime = hrtime(true);
    $totalTime = ($endTime - $startTime) / 1000000000;
    $totalReadTimeSeconds = $totalReadTime / 1000000000;
    printf("2x Push then shift from SplDoublyLinkedList: n=%8d iterations=%8d\n=> max memory=%8d bytes, create+destroy time=%.3f shift time = %.3f total time = %.3f result=%d\n",
        $n, $iterations, $maxMemory - $startMemory, $totalTime - $totalReadTimeSeconds, $totalReadTimeSeconds, $totalTime, $total);
}
$n = 2**20;
$iterations = 10;
$sizes = [
    [1, 8000000],
    [4, 2000000],
    [8, 1000000],
    [1024, 20000],
    [2**20, 20],
];
echo "Test creating a collection, then two cycles of push+shift (adding n values to the end of collections then shifting all of them from front of collection)\n";
printf(
    "Results for php %s debug=%s with opcache enabled=%s\n\n",
    PHP_VERSION,
    PHP_DEBUG ? 'true' : 'false',
    json_encode(function_exists('opcache_get_status') && (opcache_get_status(false)['opcache_enabled'] ?? false))
);

foreach ($sizes as [$n, $iterations]) {
    bench_array($n, $iterations);
    bench_deque($n, $iterations);
    bench_spl_dll($n, $iterations);
    echo "\n";
}
</code>

=== Benchmarking only appending to a Deque and reading elements without removal ===

<code php>
<?php

function bench_array(int $n, int $iterations) {
    $totalReadTime = 0.0;
    $startTime = hrtime(true);
    $total = 0;
    for ($j = 0; $j < $iterations; $j++) {
        $startMemory = memory_get_usage();
        $values = [];
        for ($i = 0; $i < $n; $i++) {
            $values[] = $i;
        }
        $startReadTime = hrtime(true);
        for ($i = 0; $i < $n; $i++) {
            $total += $values[$i];
        }
        $endReadTime = hrtime(true);
        $totalReadTime += $endReadTime - $startReadTime;

        $endMemory = memory_get_usage();
        unset($values);
    }
    $endTime = hrtime(true);

    $totalTime = ($endTime - $startTime) / 1000000000;
    $totalReadTimeSeconds = $totalReadTime / 1000000000;
    printf("Appending to array:         n=%8d iterations=%8d memory=%8d bytes, create+destroy time=%.3f read time = %.3f result=%d\n",
        $n, $iterations, $endMemory - $startMemory, $totalTime - $totalReadTimeSeconds, $totalReadTimeSeconds, $total);
}
function bench_deque(int $n, int $iterations) {
    $startTime = hrtime(true);
    $totalReadTime = 0.0;
    $total = 0;
    for ($j = 0; $j < $iterations; $j++) {
        $startMemory = memory_get_usage();
        $values = new Deque();
        for ($i = 0; $i < $n; $i++) {
            $values[] = $i;
        }

        $startReadTime = hrtime(true);
        for ($i = 0; $i < $n; $i++) {
            $total += $values[$i];
        }
        $endReadTime = hrtime(true);
        $totalReadTime += $endReadTime - $startReadTime;

        $endMemory = memory_get_usage();
        unset($values);
    }
    $endTime = hrtime(true);
    $totalTime = ($endTime - $startTime) / 1000000000;
    $totalReadTimeSeconds = $totalReadTime / 1000000000;
    printf("Appending to Deque:         n=%8d iterations=%8d memory=%8d bytes, create+destroy time=%.3f read time = %.3f result=%d\n",
        $n, $iterations, $endMemory - $startMemory, $totalTime - $totalReadTimeSeconds, $totalReadTimeSeconds, $total);
}
// SplStack is a subclass of SplDoublyLinkedList, so it is a linked list that takes more memory than needed.
// Access to values in the middle of the SplStack is also less efficient.
function bench_spl_stack(int $n, int $iterations) {
    $startTime = hrtime(true);
    $totalReadTime = 0.0;
    $total = 0;
    for ($j = 0; $j < $iterations; $j++) {
        $startMemory = memory_get_usage();
        $values = new SplStack();
        for ($i = 0; $i < $n; $i++) {
            $values->push($i);
        }
        $startReadTime = hrtime(true);
        // Random access is linear time in a linked list, so use foreach instead
        foreach ($values as $value) {
            $total += $value;
        }
        $endReadTime = hrtime(true);
        $totalReadTime += $endReadTime - $startReadTime;
        $endMemory = memory_get_usage();
        unset($values);
    }
    $endTime = hrtime(true);
    $totalTime = ($endTime - $startTime) / 1000000000;
    $totalReadTimeSeconds = $totalReadTime / 1000000000;
    printf("Appending to SplStack:      n=%8d iterations=%8d memory=%8d bytes, create+destroy time=%.3f read time = %.3f result=%d\n",
        $n, $iterations, $endMemory - $startMemory, $totalTime - $totalReadTimeSeconds, $totalReadTimeSeconds, $total);
}
function bench_spl_fixed_array(int $n, int $iterations) {
    $startTime = hrtime(true);
    $totalReadTime = 0.0;
    $total = 0;
    for ($j = 0; $j < $iterations; $j++) {
        $startMemory = memory_get_usage();
        $values = new SplFixedArray();
        for ($i = 0; $i < $n; $i++) {
            // Imitate how push() would be implemented in a situation
            // where the number of elements wasn't actually known ahead of time.
            // erealloc() tends to extend the existing array when possible.
            $size = $values->getSize();
            $values->setSize($size + 1);
            $values->offsetSet($size, $i);
        }
        $startReadTime = hrtime(true);
        for ($i = 0; $i < $n; $i++) {
            $total += $values[$i];
        }
        $endReadTime = hrtime(true);
        $totalReadTime += $endReadTime - $startReadTime;
        $endMemory = memory_get_usage();
        unset($values);
    }
    $endTime = hrtime(true);
    $totalTime = ($endTime - $startTime) / 1000000000;
    $totalReadTimeSeconds = $totalReadTime / 1000000000;
    printf("Appending to SplFixedArray: n=%8d iterations=%8d memory=%8d bytes, create+destroy time=%.3f read time = %.3f result=%d\n\n",
        $n, $iterations, $endMemory - $startMemory, $totalTime - $totalReadTimeSeconds, $totalReadTimeSeconds, $total);
}
$n = 2**20;
$iterations = 10;
$sizes = [
    [1, 8000000],
    [4, 2000000],
    [8, 1000000],
    [2**20, 20],
];
printf(
    "Results for php %s debug=%s with opcache enabled=%s\n\n",
    PHP_VERSION,
    PHP_DEBUG ? 'true' : 'false',
    json_encode(function_exists('opcache_get_status') && (opcache_get_status(false)['opcache_enabled'] ?? false))
);

foreach ($sizes as [$n, $iterations]) {
    bench_array($n, $iterations);
    bench_deque($n, $iterations);
    bench_spl_stack($n, $iterations);
    bench_spl_fixed_array($n, $iterations);
    echo "\n";
}
</code>