====== PHP RFC: Add return type declarations for internal methods ======
  * Date: 2021-03-06
  * Author: Máté Kocsis <kocsismate@php.net>
  * Status: Under Discussion
  * Implementation: https://github.com/php/php-src/pull/6548

===== Introduction =====

PHP 8.0 added parameter and return type declarations for the vast majority of internal functions and methods ([[https://github.com/php/php-src/pulls?q=is%3Apr+label%3AStubs+is%3Aclosed|Stubs initiative]]) because the different variance-related RFCs, as well as the  [[rfc:consistent_type_errors|PHP RFC: Consistent type errors for internal functions]], the [[rfc:union_types_v2|PHP RFC: Union Types 2.0]], and the [[rfc:mixed_type_v2|PHP RFC: Mixed Type v2]] RFCs made it possible to cover 99% of the cases. However, there are a few reasons why type information can be still missing:
  * **When a type includes resources:** it's not possible to declare types containing resources as there is no ''resource'' type declaration. However, resources are currently being phased out ([[https://github.com/php/php-tasks/issues/6|Resource to object migration]]), so there are less and less of such type declarations each day.
  * **When a function or method doesn't parse parameters according to the general rules:** This can be the case when e.g. an internal function or method doesn't respect the strict_types mode. PHP 8.0 fixed lots of such issues, but around 250 parameters are still not parsed correctly, due to various reasons. These could be fixed individually in the future.
  * **For ''out'' pass-by-ref parameters**: the type of these parameters is not validated during ZPP, thus it would be incorrect to declare any type for the parameters in question. An in/out parameter RFC would be a prerequisite in order to do so.
  * **For the return type of non-final methods**: According to the covariance rules, adding return types to overridden methods constitutes as a BC break due to the incompatible signature error doing so would result in. As all non-final internal methods are possibly overridden, the PHP project leaders decided not to cause such a big BC break just yet.

The current RFC aims to solve the last problem by providing a longer term, granular migration path for users to update their codebases with the necessary method return types.

===== Proposal =====

Internal method return types are declared tentatively in PHP 8.1, and they will become enforced in PHP 9.0. It means that in PHP 8.x versions, a "strict standards" notice is raised during inheritance checks when an internal method is overridden in a way that the return types are incompatible, and PHP 9.0 will makes these a fatal error. A few examples:

The overriding method doesn't declare any return type (PHP 8.1):

<code php>
class MyDateTime extends DateTime
{
    public function modify(string $modifier) { return false; }
}

// Strict standards: Declaration of MyDateTime::modify(string $modifier) should be
// compatible with DateTime::modify(string $modifier): DateTime|false
</code>

The overriding method doesn't declare any return type (PHP 9.0):

<code php>
class MyDateTime extends DateTime
{
    public function modify(string $modifier) { return false; }
}

// Fatal error: Declaration of MyDateTime::modify(string $modifier) must be
// compatible with DateTime::modify(string $modifier): DateTime|false
</code>

The overriding method declares a wrong return type (PHP 8.1):

<code php>
class MyDateTime extends DateTime
{
    public function modify(string $modifier): ?DateTime { return null; }
}

// Strict standards: Declaration of MyDateTime::modify(string $modifier): ?DateTime should be
// compatible with DateTime::modify(string $modifier): DateTime|false
</code>

The overriding method declares a wrong return type (PHP 9.0):

<code php>
class MyDateTime extends DateTime
{
    public function modify(string $modifier): ?DateTime { return null; }
}

// Fatal error: Declaration of MyDateTime::modify(string $modifier): ?DateTime must be
// compatible with DateTime::modify(string $modifier): DateTime|false
</code>

Unfortunately, union return types impose a compatibility challenge for libraries: as this construct is only supported since PHP 8.0, libraries would have to accept the fact that their code triggers E_STRICT notices on PHP 8.1 if they also want to support PHP 7 versions. In order to circumvent the issue, this RFC proposes to add a ''SuppressReturnTypeNotice'' annotation which would suppress the notice as it can be seen below:

<code php>
class MyDateTime extends DateTime
{
    /**
     * @return DateTime|false
     */
    #[SuppressReturnTypeNotice]
    public function modify(string $modifier) { return false; }
}

// No notice is triggered 
</code>

====== Reflection ======

Two new methods are proposed for addition to the ''ReflectionMethod'' class in order to provide reflection information about tentative return types:

<code php>
class ReflectionMethod
{
    public function hasTentativeReturnType(): bool {}
    public function getTentativeReturnType(): ?ReflectionType {}
}
</code>

As tentative return types are considered similarly as PHPDoc return type hints, ''ReflectionMethod::hasReturnType()'' and ''ReflectionMethod::getReturnType()'' returns ''false'' and ''null'', respectively, when a method has a tentative return type.

===== Backward Incompatible Changes =====

In PHP 8.1, an E_STRICT notice would be raised for each method which has an incompatible return type with its overridden internal method. In PHP 9.0, incompatible return types would always trigger a fatal error.


===== Future Scope =====

Tentative return types could be extended to user-land methods by using a ''TentativeReturnType'' annotation. This would be useful for libraries that want to add return types gradually.

===== Vote =====

Add return type declarations for internal methods? The vote requires 2/3 majority to be accepted.