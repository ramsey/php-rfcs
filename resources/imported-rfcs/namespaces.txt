====== Request for Comments: Namespace Issues ======
  * Version: 1.0
  * Date: 2008-03-06
  * Author: Jochem Maas <jochem@iamjochem.com>
  * Status: Work in Progress
  * First Published at: http://wiki.php.net/rfc/namespaces

===== Introduction =====

The purpose of this RFC is to document issues regarding the current namespace implementation, whether percieved or otherwise. 

==== Why this document ====

This document serves as summary of outstanding issues in order to aid discussion and resolution thereof.

==== Common Misconceptions ====

This document does not serve to force any particular changes in the engine regarding namespaces, as such any or all of the issues defined may at some stage 
be declared resolved without any implementation changes; It should accepted that some issues may only exist in so far that users have misinterpreted the
current namespace functionality.  

===== Issue Resolution =====

It is envisaged that all the issues raised in this document will be resolved in one of the following ways:

  - via functional changes to the current implementation
  - via the introduction of functional limitations (e.g. **E_WARNING** or **E_FATAL** errors) that alert php users to problems with there use of namespaces 
  - via user education, to this end a seperate document is being developed in order to define guidelines and 'best practices' with regard to namespaces (see: [[doc:scratchpad:namespaces]])


===== Issues =====

The following issues have been put forwards by various members of the php developers group and php users at large, the issues are covered in the following sections:

  * global & namespaced code in one file
  * define() & defined()
  * Autoload & functions
  * Importing NameSpace::*
  * Importing functions
  * Name resolution order
  * Keywords in namespace names
  * Namespace must be first declaration in file
  * Namespaces aren't implemented like in ...

** TODO: I'm currently scouring the web/mailinglists for everything I can find -- and testing/writing repro-code as fast as I can **

==== global & namespaced code in one file ====
currently one can declare multiple namespaces per file, but it is not possible to have code in the global scope in a file that declares namespaces, this is seen by some as an artificial limitation that forces some developers to change their project structures and as such breaks system that make use of (automated) source file concatenation (for performance reasons & distrubition), this is issue is being tackled in a seperate rfc and won't be covered here. (see [[rfc:namespacecurlies]]) 
 
==== define() & defined() ====
currently one can declare constants in namespaces (in the same way as can be done in classes) as well as using the **define()** function inside namespaced code,
but problems arise due to inconsistencies, these are:

  * constants are case-sensitive, but namespaces are case-insensitive.   
  * **defined()** is not aware of namespace aliases.
  * the namespace part of constants defined with **const** are lowercased.

the following code tries to demonstrate the issues:

ns.inc:
<code php>
<?php
namespace MY::TEST::NS;

// compile time namespaced constant
const DEBUG_NS = true;
// runtime global constant defined in namespaced code
define('DEBUG', true);
// runtime namespaced constant defined in namespaced code
define(__NAMESPACE__.'::DEBUG_2', true);
?>
</code>

test1.php:
<code php>
<?php
// include namespaced code
include './ns.inc';
// declare an alias for the namespace
use MY::TEST::NS as MTN;
// perform some tests
echo "defined('DEBUG'): "                 .(defined('DEBUG')                  ? 'YES' : 'NO')." (expect YES)\n";
echo "defined('MY::TEST::NS::DEBUG_2'): " .(defined('MY::TEST::NS::DEBUG_2')  ? 'YES' : 'NO')." (expect YES)\n";
echo "defined('my::test::ns::DEBUG_2'): " .(defined('my::test::ns::DEBUG_2')  ? 'YES' : 'NO')." (expect NO)\n";
echo "defined('my::test::ns::debug_2'): " .(defined('my::test::ns::debug_2')  ? 'YES' : 'NO')." (expect NO)\n";
echo "defined('MY::TEST::NS::DEBUG_NS'): ".(defined('MY::TEST::NS::DEBUG_NS') ? 'YES' : 'NO')." (expect YES)\n";
echo "defined('my::test::ns::DEBUG_NS'): ".(defined('my::test::ns::DEBUG_NS') ? 'YES' : 'NO')." (expect NO)\n";
echo "defined('my::test::ns::debug_ns'): ".(defined('my::test::ns::debug_ns') ? 'YES' : 'NO')." (expect NO)\n";
echo "defined('MTN::DEBUG_NS'): "         .(defined('MTN::DEBUG_NS')          ? 'YES' : 'NO')." (expect YES)\n";
echo "defined('MTN::DEBUG_2'): "          .(defined('MTN::DEBUG_2')           ? 'YES' : 'NO')." (expect YES)\n";
echo "defined('mtn::DEBUG_NS'): "         .(defined('mtn::DEBUG_NS')          ? 'YES' : 'NO')." (expect YES)\n";
echo "defined('mtn::DEBUG_2'): "          .(defined('mtn::DEBUG_2')           ? 'YES' : 'NO')." (expect YES)\n";
?>
</code>

test1.php output with expected results given in brackets:
<code>
defined('DEBUG'): YES (expect YES)
defined('my::test::ns::DEBUG_2'): NO (expect YES)
defined('my::test::ns::DEBUG_2'): NO (expect NO)
defined('my::test::ns::debug_2'): NO (expect NO)
defined('MY::TEST::NS::DEBUG_NS'): YES (expect YES)
defined('my::test::ns::DEBUG_NS'): YES (expect NO)
defined('my::test::ns::debug_ns'): NO (expect NO)
defined('MTN::DEBUG_NS'): NO (expect YES)
defined('MTN::DEBUG_2'): NO (expect YES)
defined('mtn::DEBUG_NS'): NO (expect YES)
defined('mtn::DEBUG_2'): NO (expect YES)
</code>

test2.php:
<code php>
<?php
// include namespaced code
include './ns.inc';
// declare an alias for the namespace
use MY::TEST::NS as MTN;
// output declared constants
$cnsts = get_defined_constants(true);
var_dump($cnsts['user']);
?>
</code>

test2.php actual output:
<code>
array(3) {
  ["my::test::ns::DEBUG_NS"]=>
  bool(true)
  ["DEBUG"]=>
  bool(true)
  ["MY::TEST::NS::DEBUG_2"]=>
  bool(true)
}
</code>

test2.php expected output:
<code>
array(3) {
  ["MY::TEST::NS::DEBUG_NS"]=>
  bool(true)
  ["DEBUG"]=>
  bool(true)
  ["MY::TEST::NS::DEBUG_2"]=>
  bool(true)
}
</code>

test3.php:
<code php>
<?php
// include namespaced code
include './ns.inc';
// declare an alias for the namespace
use MY::TEST::NS as MTN;
// attempt to use constants directly
var_dump(
    'the following are expected to be TRUE',
    (DEBUG === true),
    (MTN::DEBUG_NS === true),
    (MY::TEST::NS::DEBUG_NS === true)
);
var_dump(
    'the following are expected to be FALSE',
    (debug === true),
    (mtn::DEBUG_NS === true),
    (my::test::ns::DEBUG_NS === true)
);
var_dump(
    'the following are expected to be TRUE (but give Fatal Error: Class not found)',
    '(MTN::DEBUG_2 === true)',
    '(MY::TEST::NS::DEBUG_2 === true)'
);
/*
var_dump(
    'the following are expected to be ??? (and give Fatal Error: Class not found)',
    '(MY::TEST::NS::debug_ns === true)',
    '(my::test::ns::debug_ns === true)',
    '(MY::TEST::NS::debug_2 === true)',
    '(my::test::ns::DEBUG_2 === true)',
    '(my::test::ns::debug_2 === true)',
    '(MTN::debug_ns === true)',
    '(mtn::debug_ns === true)',
    '(MTN::debug_2 === true)',
    '(mtn::DEBUG_2 === true)',
    '(mtn::debug_2 === true)'
);
//*/
?>
</code>

test3.php output:
<code>
string(37) "the following are expected to be TRUE"
bool(true)
bool(true)
bool(true)
string(38) "the following are expected to be FALSE"
bool(false)
bool(true)
bool(true)
string(60) "the following are expected to be TRUE (but give fatal error)"
string(23) "(MTN::DEBUG_2 === true)"
string(32) "(MY::TEST::NS::DEBUG_2 === true)"
</code>

the above examples raise the following questions:
  * which of the inconsistencies can be resolved through documentation?
  * which of the inconsistencies can be resolved through changes to the implementation?
  * given the potential for confusion, and the potential difficulty of implementing a solution, is it worth keeping the ability to define constants (with **const**) directly in namespaces? 

==== Autoload & functions ====
The engine does not support the autoloading of functions, additionally it is not currently possible to alias functions via the use statement (a seperate issue). It has been suggested that the way to use namespaced functions is as follows (example1.php):

ns_funcs.inc (serves as the namespaced include file for all the examples in this section):
<code php>
<?php
namespace MY::TEST::NS;

function tryme() { echo "hello world from ".__FUNCTION__."!\n"; }

class Test { function tryme() { echo "hello world from ".__METHOD__."!\n"; }}

// simple echo statement to show the file has been included
// this echo statement does not effect the behaviour of any of the relevant tests
// (test this yourself by removing it!) 
echo __FILE__,' containing ',__NAMESPACE__," included\n";
<php>

example1.php
<code php>
<?php
include './ns_funcs.inc';
use MY::TEST::NS as MTN;

MTN::tryme();
</code>

output form example1.php
<code>
<PATH>/ns_funcs.inc containing MY::TEST::NS included
hello world from MY::TEST::NS::tryme!
</code>

example1.php works displaying the 'hello world' message, additionally **%%__FUNCTION__%%** displays the fully qualified name of the function as would be expected.

something strange happens when we replace the simple **include** statement with a trivia **%%__autoload()%%** definition and rely on the **use** statement to 
trigger the inclusion of //ns_funcs.php//, the function is seemingly not available and we are confronted with a fatal error instead of the 'hello world' output message:

example2.php:
<code php>
<?php
function __autoload($c) { include_once './ns_funcs.inc'; }

use MY::TEST::NS as MTN;

MTN::tryme();
</code>

output from example2.php
<code>
<PATH>/ns_funcs.inc containing MY::TEST::NS included

Fatal error: Class 'MY::TEST::NS' not found in <PATH>/funcs2.php on line 6
</code>

The problem doesn't have to do with the use of the alias (MTN), example3.php also demonstrates the fatal error:

example3.php:
<code php>
<?php
function __autoload($c) { include_once './ns_funcs.inc'; }

use MY::TEST::NS as MTN;

MY::TEST::NS::tryme();
</code>

output from example3.php
<code>
<PATH>/ns_funcs.inc containing MY::TEST::NS included

Fatal error: Class 'MY::TEST::NS' not found in <PATH>/funcs2.php on line 6
</code>

We can magically make the function available merely by using a class in the autoloaded, aliased namespace:

example4.php:
<code php>
<?php
function __autoload($c) { include_once './ns_funcs.inc'; }

use MY::TEST::NS as MTN;

$test = new MTN::Test;

MY::TEST::NS::tryme();
</code>

output from example4.php
<code>
<PATH>/ns_funcs.inc containing MY::TEST::NS included
hello world from MY::TEST::NS::tryme!
</code>

The problem illustrated above demonstrates a bug in the engine related to autoloading as triggered by **use** statements, the following points are put forward:

  * **use** statements can differentiate between that alias namespaced classes and those that alias namespaces.
  * **use** statements are not checked to see if they reference a valid namespace or namespaced class (this issue is also described seperately below)
  * one can autoload namespaces, but it is only usable when using namespaced classes. 

==== Importing NameSpace::* ====

==== Importing functions ====

==== Name resolution order ====

==== Keywords in namespace names ====

==== Namespace must be first declaration in file ====
Currently if you wish to declare one or more namespaces in a file nothing may preceed the initial namespace declaration, __with the exception of white-space & comments between the initial php parser tag (**<?php**) and the initial namespace declaration__ (one can include as many comment blocks as one want's preceeding the initial namespace declaration in a file) .

Two seperate types of preceeding 'code' both cause fatal errors, both of which seem to be an unnatural restrictions:
  * Global Code
  * Inline Output 

=== Global Code ===
No code may preceed a namespace declaration, given that php has never laid restriction or placed any requirement on code or file layout before and given that the php namespace functionality explicitly does not attempt to be a //package// like mechanism (i.e. there is no direct 1 to 1 relationship between files and namespaces that the engine can enforce or rely on), it seems unduly restrictive and counter-intuitive that the following two examples are not functionally identical (the second example results in a fatal error):

example1.inc
<code php>
<?php
namespace MY::TEST::NS;
class Foo {}
?>
</code>

example1.php
<code php>
<?php
echo "in the global scope!\n";
include './example1.inc';
?>
</code>

example2.php
<code php>
<?php
echo "in the global scope!\n";
namespace MY::TEST::NS;
class Foo {}
?>
</code>

=== Inline Output ===
No output may occur, whitespace or otherwise, prior to the opening php parser tag, in a file that declares one or more namespaces. Again this seems unduly restrictive, granted it may not be good practice to have such output in files that declare namespaces, but there is no technical limitation that warrants it either, one could also argue that unintentional output (e.g. an unintentional space) is somewhat less painful to the functioning of a body of code than a fatal error. The following example demostrates a file that triggers the fatal error: 

example3.php
<code php>
 <?php
namespace MY::TEST::NS;
class Foo {}

?>
</code>

==== Namespaces aren't implemented like in ... ====
PHP is not <insert your favorite language here>. Granted this is not an issue, but some of you reading this probably need something to smile about after reading the items above!

===== Miscellaneous =====

  * An RFC discussing namespaces for internal classes exists (see: [[[rfc:namespaces-for-internal-classes]]])
  * A scratchpad document is being worked on to gather namespace 'best practices' which will hopefully be incorporated into the official manual at some stage (see: [[doc:scratchpad:namespaces]]) 

===== Changelog =====

