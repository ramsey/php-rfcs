====== PHP RFC: User-defined object comparison ======
  * Version: 0.3
  * Date: 2018-06-26
  * Author: Rudi Theunissen <rtheunissen@php.net>
  * Based on previous RFC by: Adam Harvey <aharvey@php.net>
  * Proposed PHP version: PHP 7.3
  * Implementation: https://github.com/php/php-src/pull/3339
  * Status: Under Discussion

===== Background =====

The discussion around user-defined comparison dates back to 2010 when the 
[[https://wiki.php.net/rfc/comparable|Comparable RFC]] was introduced for the 
first time and later updated in 2015. This RFC is an attempt to build on the
motivation behind that RFC with a new proposal.

===== Introduction =====

This RFC introduces the ability for a user to override the default comparison 
behaviour of objects in PHP, and builds heavily on the work that Adam Harvey did
on the [[https://wiki.php.net/rfc/comparable|Comparable RFC]].

==== The problem we're trying to solve ====

The current [[http://php.net/manual/en/language.oop5.object-comparison.php|default behaviour]] 
was introduced in PHP 5 and compares two objects by recursively comparing their properties using ''==''. Ordering (''%%<%%'', ''%%>%%'') stops and returns at the first unequal property found. There are some potential pitfalls to this approach though:

  * **Changing the order of properties might change the relative ordering of an object**, because the order in which properties are inspected is the order in which they are defined in the class. This is not intuitive or transparent, and may lead to unintended behaviour. It's also currently not documented anywhere.
  * **There is no way to compare properties strictly**. This RFC will change that by giving the user the ability to compare objects based on specific properties however they require.
  * **Recursive property comparison is unnecessarily slow in some cases**. Some classes with many properties might be an identifier that can be used to determine equality. There is currently no way to leverage that, and the engine has to compare every single property, some of which may also be objects.
  * **Extensions can override comparison, but userland can not.** This creates an inconsistency between extensions and userland, which prevents support for polyfills.

==== Use cases ====

It's safe to say that objects are not frequently compared in PHP today. This might be because the user can't control the behaviour, or because use cases aren't common. Most objects won't concern themselves with comparability and won't implement these methods, but those that do will find a lot of value in the ability to control comparison.

Cases that might benefit from non-default comparison behaviour:
  * Number types like decimals, big integers and fuzzy precision values.
  * Streams or resources where a buffer or connection shouldn't be considered.
  * Strict sets that differentiate between <php>"1"</php> and <php>1</php>.
  * Active record models where the entity's attributes are embedded.
  * Objects that have complex relationships between properties to determine ordering and equality.
  * Cases where an object wants to disallow comparison entirely to guard against unintended behaviour.
  * Cases where an equal ordering does not imply equal value, eg. Decimal(2.00) <=> int(2).
  * Cases where ordering isn't naturally ascending or lexicographical.

==== Support in other languages ====

For reference, some major languages that also support user-defined comparable objects:
  * Java has a [[https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html|Comparable]] interface.
  * Python 2 has the //[[https://docs.python.org/2/reference/datamodel.html#object.__cmp__|__cmp__]]// magic method.
  * Python 3 removed //%%__cmp__%%// in favour of [[https://docs.python.org/2/reference/datamodel.html#object.__lt__|rich comparison]] magic methods.
  * Ruby has a [[https://ruby-doc.org/core-2.4.0/Comparable.html|Comparable]] module.
  * .NET has an [[https://msdn.microsoft.com/en-us/library/system.icomparable(v=vs.110).aspx|IComparable]] interface.

===== Proposal =====

This RFC introduces two new magic methods: **//%%__compareTo%%//** and **//%%__equals%%//**.

These can be used to change the default behaviour of objects when compared to 
other values, including scalars. There's also a new object handler called //equals// that is the internal equivalent of //%%__equals%%//.

<code php>
class Example
{
    /**
     * Returns: < 0 if $this is less than $other,
     *          > 0 if $this is greater than $other,
     *         == 0 if $this has equal natural ordering to $other.
     */
    public function __compareTo($other)
    {
        ...
    }

    /**
     * @returns bool TRUE if $this is equal to $other, FALSE otherwise.
     */
    public function __equals($other): true
    {
        ...
    }
}
</code>

==== __compareTo ====

When an object is compared in a context that considers **natural ordering**, such as <php>sort</php>, the //%%__compareTo%%// method is called to determine its relative ordering compared to the value it received. It should return  a value < 0 if smaller, 0 if equal, and > 0 if greater. Objects that don't 
implement //%%__compareTo%%// will continue to use the [[http://php.net/manual/en/language.oop5.object-comparison.php#98725|default behaviour]] that was introduced in PHP 5. 

Explicitly disallowing ordering can be done by throwing an exception in //%%__compareTo%%//.

An implementor of ''%%__compareTo%%'' should ensure that:
  * <php>$x.__compareTo($y)</php> is inversely equivalent to <php>$y.__compareTo($x)</php>.
  * <php>$x.__compareTo($y)</php> should throw an exception if <php>$y.__compareTo($x)</php> does.
  * <php>$x.__compareTo($y) > 0 && $y.__compareTo($z) > 0</php> requires that <php>$x.__compareTo($z) > 0</php>.
  * <php>$x.__compareTo($y) < 0 && $y.__compareTo($z) < 0</php> requires that <php>$x.__compareTo($z) < 0</php>.
  * <php>$x.__compareTo($y) == 0 && $y.__compareTo($z) == 0</php> requires that <php>$x.__compareTo($z) == 0</php>.

While this might seem like a lot of responsibility and complexity, these requirements are easily met if the implementor
applies the same logic consistently and sensibly.

==== __equals ====

When an object is compared in a context that considers **equality**, such as 
<php>in_array</php>, the //%%__equals%%// method is called to determine if 
the object is equal to the value it received. It should return **TRUE** if equal, or **FALSE** otherwise. 
Objects that don't implement //%%__equals%%// will continue to use the 
[[http://php.net/manual/en/language.oop5.object-comparison.php|default behaviour]] 
that was introduced in PHP 5.

An implementor of ''%%__equals%%'' should ensure that:
  * <php>$x.__equals($y)</php> is equivalent to <php>$y.__equals($x)</php>.
  * <php>$x.__equals($y)</php> should throw an exception if <php>$y.__equals($x)</php> does.
  * <php>$x.__equals($y) && $y.__equals($z)</php> requires that <php>$x.__compareTo($z) == TRUE</php>.

==== Behaviour in combination ====

Using either or both of these methods covers three common scenarios:
  - I want to define equality but ordering doesn't make sense. (//%%__equals%%// only).
  - I want to define ordering, and equal ordering implies equal value. (//%%__compareTo%%// only).
  - I want to define ordering, but equal ordering does not mean equal value for this object. (//%%__compareTo%%// and //%%__equals%%//).

**Note:** Objects that only implement //%%__compareTo%%// will be equal to any value for which //%%__compareTo%%// returns 0. See [[#open_issues]].

^ Expressions                                                                                       ^ Attempted calling order                                                                                             ^
| ''%%$a < $b%%'',\\ ''%%$a > $b%%'',\\ ''%%$a <= $b%%'',\\ ''%%$a >= $b%%'',\\ ''%%$a <=> $b%%''   | ''%%$a->__compareTo($b)%%'',\\ ''%%$b->__compareTo($a)%%''                                                          |
| ''%%$a == $b%%'',\\ ''%%$a != $b%%''                                                              | ''%%$a->__equals($b)%%'',\\ ''%%$b->__equals($a)%%'',\\ ''%%$a->__compareTo($b)%%'',\\ ''%%$b->__compareTo($a)%%''  |

==== Why should PHP support this at a language level? ====

There are a few userland implementations but there is no way for them to affect
the internals of array functions and operators. The only way that we can dictate a standard of behaviour is by implementing this at a language level.

==== Why magic methods over an interface? ====

Python uses magic methods because there are no interfaces. Java has a 
Comparable interface because not all objects are comparable by default. It's 
important to note that we're not exposing the ability to make an object comparable, but instead to change the default behaviour when compared. All 
objects in PHP are technically already comparable.

  * No risk of breaking backwards compatibility or unintended behaviour because method names that start with %%"__"%% are always reserved.
  * All objects can already be compared and tested for equality, so checking if an object implements an interface would not give you any useful information. 
  * PHP already uses magic methods to change the default behaviour of objects.

There is a case for an interface when it comes to generics. Depending on the syntax, we would be able to do something like this:

<code php>
class Example<T> implements Comparable
{
    public function __compareTo(T $other)
    {
        ...
    }
}
</code>

However, because magic methods aren't inherited and the only restrictions are 
that they need to be public and non-static, there's nothing stopping you from
doing something like this:

<code php>
class Example
{
    public function __compareTo(Example $other): int
    {
        ...
    }
}
</code>

===== Effects on Existing Functions =====

Any functions that use the internal ''compare_function'' or ''is_equal_function'' will be affected, which includes
array functions like <php>sort</php>, <php>array_search</php> and <php>in_array</php>.

===== Changes to Operators =====

These methods also overload operators. Here is a table to demonstrate this:

^ Operator      ^ Primary               ^ Secondary             ^                                                                                                 ^
| ''%%<%%''     | //%%__compareTo%%//   |                       | **TRUE** if //%%__compareTo%%// returns %%<%% 0                                                     |
| ''%%>%%''     | //%%__compareTo%%//   |                       | **TRUE** if //%%__compareTo%%// returns %%>%% 0                                                     |
| ''%%<=%%''    | //%%__compareTo%%//   |                       | **TRUE** if //%%__compareTo%%// returns %%<=%% 0                                                    |
| ''%%>=%%''    | //%%__compareTo%%//   |                       | **TRUE** if //%%__compareTo%%// returns %%>=%% 0                                                    |
| ''%%==%%''    | //%%__equals%%//      | //%%__compareTo%%//   | **TRUE** if //%%__equals%%// is **not** implemented and //%%__compareTo%%// returns 0.          |
| ''%%!=%%''    | //%%__equals%%//      | //%%__compareTo%%//   | **TRUE** if //%%__equals%%// is **not** implemented and //%%__compareTo%%// returns non-zero.   |
| ''%%===%%''   |                       |                       | No change to default behaviour.                                                                 |
| ''%%!==%%''   |                       |                       | No change to default behaviour.                                                                 |

===== Backward Incompatible Changes =====

None. 

Objects that do not implement //%%__compareTo%%// or //%%__equals%%// will
continue to use the existing rules and are therefore not affected by this patch.

==== To Existing Extensions ====

Extensions that use the ''compare'' object handler may be affected by this patch 
because **NULL** is now passed to the handler, where it used to always 
return 1 if the object is on the LHS or -1 if on the RHS.

The result of the ''compare'' handler will only be used if the handler returned 
SUCCESS. Returning FAILURE will cause the comparison to fall through to the 
''compare_objects'' handler. Currently, the result of the ''compare'' handler is 
always used, regardless of the return value.

===== Proposed PHP Version(s) =====

This would go in the next PHP 7.x, most likely 7.3.

===== Open Issues =====

==== 1. Should equality imply equal ordering when ordering isn't defined? ====

If a class doesn't implement ''%%__compareTo%%'' but ''%%__equals%%'' returns **TRUE**,
should that be treated as ''%%__compareTo%%'' returning 0?

This comes down to whether we want to completely isolate equality and ordering, even though
the convention is that equal value should imply equal ordering. It makes no sense that two
values that are equal should not be ordered as such, but it might not be intuitive to have
''%%__equals%%'' called for ''%%>%%'' or ''%%<%%''.

Current decision: **No**, it's up to the implementor to define both equality and ordering.

==== 2. Should equal ordering imply equality when equality isn't defined? ====

If a class doesn't implement ''%%__equals%%'' but ''%%__compareTo%%'' returns 0,
should that be treated as ''%%__equals%%'' returning **TRUE**?

This is the current behaviour of the internal //compare_function//, which is called by
//is_equal_function//, which returns **TRUE** if //compare_function// returned 0. So PHP does 
not currently differentiate between ordering and equality. The //compare// object handler is
the only way to define custom comparison but its result is used for both equality and ordering. 

Existing extensions will now have the option of implementing the //equals// handler if they 
want to separate ordering from equality.

Current decision: **Yes**, equal ordering implies equality if equality is not defined.

==== 3. Should __equals be restricted to instances of the same class? ====

PHP's current definition of equality (when ''=='' is called on two objects) require that
the two compared objects be instances of the same class. Even if one class is an extension
of the other, ''=='' will be **FALSE** unless they are exactly the same class.

Only internal classes and extensions can currently override this behaviour. For example, 
GMP does not require for the other value to be a GMP number, 
eg. <php>gmp_init(42) == 42</php> will be **TRUE**. This is because the //compare// 
object handler allows an object to be compared to any other type.

However, one major advantage of restricting operands to the same class is that equality 
would be symmetrical by design, because both values would have the same comparison function. 

Current decision: **No**, it's up to the user to do an <php>instanceof</php> check, which allows
for greater flexibility and less inconsistency between userland and internal classes.

==== 4. Should we throw an exception when a class that doesn't define ordering is ordered? ====

Ordering an object that doesn't implement ''%%__compareTo%%'' is almost certainly unintended.
However, we don't want to break existing code by failing hard when ordering isn't defined,
but we can if ''%%__equals%%'' is implemented but ''%%__compareTo%%'' is not. 

Current decision: **Yes**, we should fail hard when an object is compared for ordering when 
ordering is not defined, but only if ''%%__equals%%'' is defined.

===== Implementation =====
See https://github.com/php/php-src/pull/3339/files
