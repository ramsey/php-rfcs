====== PHP RFC: User-defined object comparison ======
  * Version: 0.1
  * Date: 2018-06-26
  * Author: Rudi Theunissen <rtheunissen@php.net>
  * Based on previous RFC by: Adam Harvey <aharvey@php.net>
  * Proposed PHP version: PHP 7.3
  * Implementation: https://github.com/php/php-src/pull/3339
  * Status: Draft

===== Background =====

The discussion around user-defined comparison dates back to 2010 when the 
[[https://wiki.php.net/rfc/comparable|Comparable RFC]] was introduced for the 
first time and later updated in 2015. This RFC is an attempt to build on the
motivation behind that RFC with a new proposal.

===== Introduction =====

This RFC introduces the ability for a user to override the default comparison 
behaviour of objects in PHP, and builds heavily on the work that Adam Harvey did
on the [[https://wiki.php.net/rfc/comparable|Comparable RFC]].

==== The problem we're trying to solve ====

The current [[http://php.net/manual/en/language.oop5.object-comparison.php|default behaviour]] 
was introduced in PHP 5 and compares two objects by recursively comparing their properties using ''==''. Ordering (''%%<%%'', ''%%>%%'') stops and returns at the first unequal property found. There are some potential pitfalls to this approach though:

  * **Changing the order of properties might change the relative ordering of an object**, because the order in which properties are inspected is the order in which they are defined in the class. This is not intuitive or transparent, and may lead to unintended behaviour. It's also not currently
  documented anywhere.
  * **There is no way to compare properties strictly**. This RFC will change that by giving the user the ability to compare objects based on specific properties however they require.
  * **Recursive property comparison is unnecessarily slow in some cases**. Some classes with many properties might be an identifier that can be used to determine equality. There is currently now way to leverage that, and the engine has to compare every single property, some of which may also be objects.
  * **Extensions can override comparison, but userland can not.** This creates an inconsistency between extensions and userland, which prevents support for polyfills.

==== Use cases ====

It's safe to say that objects are not frequently compared in PHP today. This might be because the user can't control the behaviour, or because use cases aren't common. Most objects won't concern themselves with comparability and won't implement these methods, but those that do will find a lot of value in the ability to control comparison.

Cases that might benefit from non-default comparison behaviour:
  * Number types like decimals, big integers and fuzzy precision values.
  * Streams or resources where a buffer or connection shouldn't be considered.
  * Strict sets that differentiate between <php>"1"</php> and <php>1</php>.
  * Active record models where the entity's attributes are embedded.
  * Objects that have complex relationships between properties to determine ordering and equality.
  * Cases where an object wants to disallow comparison entirely to guard against unintended behaviour.
  * Cases where an equal ordering does not imply equal value, eg. Decimal(2.00) <=> int(2).
  * Cases where ordering isn't naturally ascending or lexicographical.

==== Support in other languages ====

For reference, some major languages that also support user-defined comparable objects:
  * Java has a [[https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html|Comparable]] interface.
  * Python 2 has the //[[https://docs.python.org/2/reference/datamodel.html#object.__cmp__|__cmp__]]// magic method.
  * Python 3 removed //%%__cmp__%%// in favour of [[https://docs.python.org/2/reference/datamodel.html#object.__lt__|rich comparison]] magic methods.
  * Ruby has a [[https://ruby-doc.org/core-2.4.0/Comparable.html|Comparable]] module.
  * .NET has an [[https://msdn.microsoft.com/en-us/library/system.icomparable(v=vs.110).aspx|IComparable]] interface.

===== Proposal =====

This RFC introduces two new magic methods: **//%%__compareTo%%//** and **//%%__equals%%//**.
These can be used to change the default behaviour of objects when compared to 
other values, including scalars. There's also a new object handler called //equals// 
that is the internal equivalent of //%%__equals%%//.

When an object is compared in a context that considers **natural ordering**, such as
<php>sort</php>, the //%%__compareTo%%// method is called to determine its 
relative ordering compared to the value it received. It should return  a value 
< 0 if smaller, 0 if equal, and > 0 if greater. Objects that don't 
implement //%%__compareTo%%// will continue to use the 
[[http://php.net/manual/en/language.oop5.object-comparison.php#98725|default behaviour]]
that was introduced in PHP 5.

When an object is compared in a context that considers **equality**, such as 
<php>in_array</php>, the //%%__equals%%// method is called to determine if 
the object is equal to the value it received. It should return **TRUE** if equal, 
otherwise **FALSE**. Objects that don't implement //%%__equals%%// will 
continue to use the [[http://php.net/manual/en/language.oop5.object-comparison.php|default behaviour]].

We hereby support three applications:
  - I want to define equality and I don't intend to compare this object (only //%%__equals%%//). 
  - I want to define ordering and I'm okay that equal ordering implies equal value (only //%%__compareTo%%//). 
  - I want to define ordering but equal ordering does not mean equal value for this object (//%%__compareTo%%// and //%%__equals%%//).

Notes on specific behaviour and open issues:
  * If only //%%__equals%%// is implemented and returns **TRUE**, it will automatically translate to an ordering of 0. See [[#open_issues|issue #1]]
  * Objects that want to explicitly disallow ordering can throw an exception or raise a warning in //%%__compareTo%%//. See [[#open_issues|issue #2]]
  * Objects that only implement //%%__compareTo%%// will be considered equal to any value for which it returns 0. See [[#open_issues|issue #3]]

==== Why should PHP support this at a language level? ====

There are a few userland implementations but there is no way for them to affect
the internals of array functions and operators. The only way that we can dictate a standard of behaviour is by implementing this at a language level.

==== Why magic methods over an interface? ====

Python uses magic methods because there are no interfaces. Java has a 
Comparable interface because not all objects are comparable by default. It's 
important to note that we're not exposing the ability to make an object comparable, but instead to change the default behaviour when compared. All 
objects in PHP are technically already comparable.

  * No risk of breaking backwards compatibility or unintended behaviour because method names that start with __ are always reserved.
  * All objects can already be compared and tested for equality, so checking if an object implements an interface would not give you any useful information. 
  * PHP already uses magic methods to change the default behaviour of objects.

There is a case for an interface when it comes to generics. Depending on the syntax, we would be able to do something like this:

<code php>
class Example<T> implements Comparable
{
    public function __compareTo(T $other)
    {
        ...
    }
}
</code>

However, because magic methods aren't inherited and the only restrictions are 
that they need to be public and non-static, there's nothing stopping you from
doing something like this:

<code php>
class Example
{
    public function __compareTo(Example $other): int
    {
        ...
    }
}
</code>

===== Effects on Existing Functions =====

Any functions that use the internal ''compare_function'' or ''is_equal_function'' will be affected, which includes
array functions like <php>sort</php>, <php>array_search</php> and <php>in_array</php>.

===== Changes to Operators =====

These methods also overload operators. Here is a table to demonstrate this:

^ Operator      ^ Methods             ^  Fallback             ^ Notes     ^
| ''%%<%%''     | //%%__compareTo%%// |                       |           |
| ''%%>%%''     | //%%__compareTo%%// |                       |           |
| ''%%<=%%''    | //%%__compareTo%%// | //%%__equals%%//      | Will be **TRUE** if //%%__compareTo%%// is not implemented and //%%__equals%%// returns **TRUE** |
| ''%%>=%%''    | //%%__compareTo%%// | //%%__equals%%//      | Will be **TRUE** if //%%__compareTo%%// is not implemented and //%%__equals%%// returns **TRUE** |
| ''%%==%%''    | //%%__equals%%//    | //%%__compareTo%%//   | Will be **TRUE** if //%%__equals%%// is not implemented and //%%__compareTo%%// returns 0 |
| ''%%!=%%''    | //%%__equals%%//    | //%%__compareTo%%//   | Will be **FALSE** if //%%__equals%%// is not implemented and //%%__compareTo%%// returns 0 |
| ''%%===%%''   |                     |                       |           |
| ''%%!==%%''   |                     |                       |           |

===== Backward Incompatible Changes =====

None. 

Objects that do not implement //%%__compareTo%%// or //%%__equals%%// will
continue to use the existing rules and are therefore not affected by this patch.

==== To Existing Extensions ====

Extensions that use the ''compare'' object handler may be affected by this patch 
because **NULL** is now passed to the handler, where it used to always 
return 1 if the object is on the LHS or -1 if on the RHS.

The result of the ''compare'' handler will only be used if the handler returned 
SUCCESS. Returning FAILURE will cause the comparison to fall through to the 
''compare_objects'' handler. Currently, the result of the ''compare'' handler is 
always used, regardless of the return value.

===== Proposed PHP Version(s) =====

This would go in the next PHP 7.x, most likely 7.3.

===== Open Issues =====

  - Should we internally enforce that ordering is ''0'' when equality is **TRUE**, or leave it up to the user to follow this convention?
  - Should we warn the user when an object that doesn't implement //%%__compareTo%%// is compared for ordering?
  - Should //%%__compareTo%%// returning ''0'' indicate equality when  //%%__equals%%// is not defined?

===== Implementation =====
See https://github.com/php/php-src/pull/3339/files
