
====== PHP RFC: Expectations ======

  * Version: 0.done
  * Date: 2013-10-18 
  * Author: Joe Watkins, krakjoe@php.net
  * Status: Under Discussion
  * First Published at: http://wiki.php.net/rfc/expectations

===== Introduction =====

This functionality was meant to replace the assert() API that currently exists in PHP, because of problems replacing it in a compatible manner, we have renamed the implementation **expect**.

The **expectation** statement has two forms:

<code>
T_EXPECT expression ';'
</code>

<code>
T_EXPECT expression ':' message ';'
</code>

At execution time, **expression** will be evaluated, if the result is false, an **ExpectationException** will be thrown.

In some cases, **expression** will be an expensive evaluation that you do not wish to execute in a production environment, **expectations** can therefore be disabled and enabled via the **PHP_INI_PERDIR** configuration setting **zend.expectations**. Disabling Expectations will almost entirely eliminate the performance penalty making them equivalent to an empty statement.

In any case, **expectations** should never be used to perform tasks **required** for the code to function, nor should they change the internal state of any object //except where that state is used by other expectations//, these are not rules that are enforced by Zend, but are nonetheless the best rules to follow.

If an object of a class which extends **ExpectationException** is used for **message**, it will be thrown if the **expectation** fails, anything else will be used as the **message** for the **ExpectationException**. If no **message** is provided, the statement will be used as the **message** in **ExpectationException**.
===== Scope of Expectations =====

PHP programmers tend to document how their code is supposed to work in comments, this is a fine approach for generating automated documentation, but leaves us a little bewildered, and tired of digging through documentation at runtime when things go wrong:

<code php>
    if ($i % 3 == 0) {
        ...
    } else if ($i % 3 == 1) {
        ...
    } else { // We know ($i % 3 == 2)
        ...
    }
</code>

Becomes:

<code php>
    if ($i % 3 == 0) {
        ...
    } else if ($i % 3 == 1) {
        ...
    } else {
        expect ($i % 3 == 2);
    }
</code>

In a development environment, this forces the executor to make you aware of your mistake.

Another good example for using **Expectations** might be a switch block with no default case:

<code php>
switch ($suit) {
    case CLUBS:
        /* ... */
    break;
    
    case DIAMONDS:
        /* ... */
    break;
    
    case HEARTS:
        /* ... */
    break;
    
    case SPADES:
        /* ... */
    break;
}
</code>

The above switch assumes that **suit** can only be one of four values, to test this assumption add the default case:

<code php>
switch ($suit) {
    case CLUBS:
        /* ... */
    break;
    
    case DIAMONDS:
        /* ... */
    break;
    
    case HEARTS:
        /* ... */
    break;
    
    case SPADES:
        /* ... */
    break;
    
    default:
        expect false : "Unrecognized suit passed through switch: {$suit}";
}
</code>

The previous example highlights another general area where you should use expectations: **place an expectation at any location you assume will not be reached**. The statement to use is:

<code php>
expect false;
</code>

Suppose you have a method that looks like:

<code php>
public function method() {
    for (/*...*/) {
    
        if (/* ... */)
           return true;
    }
    
}
</code>

The above code assumes that one of the iterations results in a return value being passed back to the caller of **::method()**, to test this assumption:

<code php>
public function method() {
    for (/*...*/) {
    
        if (/* ... */)
           return true;
    }
    expect false;
}
</code>

**Expectations** allow the possibility to perform //precondition// and //postcondition// checks:

<code php>
public function setResponseCode($code) {
    $this->code = $code;
}
</code>

Becomes:

<code php>
public function setResponseCode($code) {
    expect $code < 550 && $code > 100 : "Invalid response code provided: {$code}";
    
    $this->code = $code;
}
</code>

The example above performs a //precondition// check on the **code** parameter.

The same kind of logic can be applied to internal object state:

<code php>
public function getResponseCode($code) {
    expect $this->code : "The response code is not yet set";
    
    return $this->code;
}
</code>

//postcondition// checks might also be carried out with expect:

<code php>
public function getNext() {
    $data = $this->data[++$this->next];
    
    expect preg_match("~^([a-zA-Z0-9-]+)$~", $data["key"]) :
        "malformed key found at {$this->next} \"{$data["key"]}\"";
    
    return $data;
}
</code>

The above method during development would be verbose, not allowing the programmer to make a mistake, while during production where expectations should be disabled, it is //fast//.
===== Managing Expectations =====

When an **expectation** fails, an **ExpectationException** is thrown, these can be caught in the normal way, and come with a stack trace and a useful message about the **expectation**. An **ExpectationException** extends **ErrorException** and has a **severity** of **E_ERROR**.

Here is an example of managing execution of an object whose methods use the **expectations** API:

<code php>
<?php
$headers = [];

try {
   while (($header = $request->getHeader())) {
       /* ... */
       $headers[] = $header;
   }  
} catch (ExpectationException $ex) {
   printf("Failed getting headers from Request: %s\n", $ex->getMessage());
   /* ... output stack trace in some pretty way perhaps ... */
   /* ... output some state and scope information ... */
   exit(1);
}
?>
</code>

You can provide custom exceptions for failed **expectations**:

<code php>
<?php
$next = 1;
$data = array(
    "key" => "X-HTTP ",
    "value" => "testing"
);

class HeaderMalfunctionException extends ExpectationException {}

/* ... */
public function getData() {
    /* ... */
    expect preg_match("~^([a-zA-Z0-9-]+)$~", $data["key"]) :
        new HeaderMalfunctionException("malformed key found at {$next} \"{$data["key"]}\"");
    /* ... */
}
/* ... */
?>
</code>

This allows the caller of **::getData** to manage more appropriately failed **expectations**.
===== Performance =====

Here's a quick comparison script:

<code php>
<?php
/* LEGACY */
$start = microtime(true);
for($i=0; $i<1000000; $i++) {
    assert("true");
}
printf("Legacy: %.3f seconds\n", microtime(true)-$start);

/* EXPECT */
$start = microtime(true);
for($i=0; $i<1000000; $i++) {
    expect true;
}
printf("Expect: %.3f seconds\n", microtime(true)-$start);
?>
</code>

Output:

<code>
[joe@fiji php-src]$ sapi/cli/php test.php
Legacy: 1.305 seconds
Expect: 0.051 seconds
[joe@fiji php-src]$ sapi/cli/php -dzend.expectations=0 -dassert.active=0 test.php
Legacy: 0.078 seconds
Expect: 0.026 seconds
[joe@fiji php-src]$ 
</code>

Needless to say **expectations** out perform **assertions** by a very wide margin, under all circumstances.

For those of us that use PHP to do all our math:

<code>
[joe@fiji php-src]$ php -r "echo ceil(1.305/0.051);"
26
</code>

And the performance of that loop on it's own:

<code php>
<?php
/* NOTHING */
$start = microtime(true);
for($i=0; $i<1000000; $i++) {
    
}
printf("Nothing: %.3f seconds\n", microtime(true)-$start);
?>
</code>

Output:

<code>
[joe@fiji php-src]sapi/cli/php test.php
Nothing: 0.024 seconds
</code>

//Tests run on a debug build of PHP yield similar, more exaggerated, results.//

**Noteworthy**: while opcache is loaded and optimization enabled, you can expect absolutely no impact from disabled **expectations** in production, it optimizes away the impact completely.

Some timings with opcache loaded:

<code php>
[joe@fiji php-src]$ sapi/cli/php -c /opt/php-nts/lib -dextension_dir=/opt/php-nts/lib/php/extensions/no-debug-non-zts-20121212/ -dzend_extension=opcache.so -dopcache.enable_cli=1 test.php
Legacy: 1.334 seconds
Expect: 0.026 seconds
[joe@fiji php-src]$ sapi/cli/php -c /opt/php-nts/lib -dextension_dir=/opt/php-nts/lib/php/extensions/no-debug-non-zts-20121212/ -dzend_extension=opcache.so -dopcache.enable_cli=1 -dassert.active=0 -dzend.expectations=0 test.php
Legacy: 0.077 seconds
Expect: 0.016 seconds
[joe@fiji php-src]$ sapi/cli/php -c /opt/php-nts/lib -dextension_dir=/opt/php-nts/lib/php/extensions/no-debug-non-zts-20121212/ -dzend_extension=opcache.so -dopcache.enable_cli=1 test.php
Nothing: 0.016 seconds
</code>

The important math:

<code>
[joe@fiji php-src]$ php -r "echo ceil(1.334/0.026);"
52
</code>


===== Production Time =====

**Expectations** are a debugging and development feature; the programmer should not take code to production with catch blocks to manage **ExpectationExceptions**; the ability to manage the **ExpectationExceptions** exists //during development// in order to aid the programmer in debugging the exception, //the only place where it can be raised//. 

Library code should not shy away from deploying **Expectations** //everywhere//, use it to literally enforce what your code **expects**, rigorously, such that during development the programmer is made aware of every possible mistake //before// production arrives. 

This means production library code does not have to manage inconsistencies in usage, because there should, theoretically, be none left; improving it's performance in production by not making those unnecessary checks that stem from inconsistent or incorrect usage.

//prefix everything here with "when deployed properly"//
===== Backward Incompatible Changes =====

Nothing internal is affected.

**expect** is a new keyword, and may cause clashes in code where the same name is used for user methods/functions.

===== Proposed PHP Version(s) =====

Undecided

===== Impact to Existing Extensions =====

None that are obvious, this does introduce a new opcode so anything working with opcodes may need adjustment.

===== php.ini Defaults =====

**Per Directory** configuration setting:
  * zend.expectations=1

**zend.expectations** is a compile time //only// setting.

Expectations should be enabled (**zend.expectations=1**) on development machines, and disabled (**zend.expectations=0**) in production.
===== Unaffected PHP Functionality =====

The current assertion API is completely unaffected by this addition.

===== Proposed Voting Choices =====

Simple

===== Patches and Tests =====

https://github.com/krakjoe/php-src/compare/expect

This is a working implementation of Expectations as documented here, with some appropriate tests.

===== References =====

Link to the original internals thread that discussed the proposal to replace assert with new functionality:

http://php.markmail.org/search/?q=net.php.lists.internals+order%3Adate-backward+assertions#query:net.php.lists.internals%20order%3Adate-backward%20assertions+page:1+mid:nxbxke2z5oykztys+state:results

Link to the internals thread discussing this particular RFC:

http://php.markmail.org/search/?q=net.php.lists.internals+expectations+order%3Arelevance#query:net.php.lists.internals%20expectations%20order%3Arelevance+page:1+mid:krr72ib3jwghrc4a+state:results

===== Other Languages =====

This implementation is almost identical to Java ...

    Java: http://docs.oracle.com/javase/1.4.2/docs/guide/lang/assert.html
        assert expression : message; evaluates Expression1 and if it is false throws an AssertionError with no detail message, takes message to constructor of AssertionError if present.

.NET (or this implementation for .NET) does not directly result in an exception, more like an exception in a message box, the important part is; it includes the call stack.

    .NET: http://msdn.microsoft.com/en-us/library/system.diagnostics.debug.assert.aspx
        Debug.Assert(expression, message): Checks for a condition; if the condition is false, outputs a specified message and displays a message box that shows the call stack.

Python's implementation is similar to **Expectations** also, bit limited

    Python: http://docs.python.org/2/reference/simple_stmts.html
        assert expression raise AssertionError
    
Javascript has no standard implementation, yet; various implementations exist all the same:

    Chrome: https://developers.google.com/chrome-developer-tools/docs/console-api#consoleassertexpression_object
        console.assert(expression, object): If the specified expression is false, the message is written to the console along with a stack trace.
    
    Firefox (firebug): http://getfirebug.com/wiki/index.php/Console_API
        console.assert(expression[, object, ...]): Tests that an expression is true. If not, it will write a message to the console and throw an exception.
    
    Node.js: http://nodejs.org/api/stdio.html#stdio_console_assert_expression_message
        console.assert(expression, [message]): Same as assert.ok() where if the expression evaluates as false throw an AssertionError with message.

These implementations at least include a stack trace; a benefit of using exceptions for failed **Expectations** is that the stack trace is present by default.

===== Opcode Information =====

The new opcode **ZEND_EXPCT** is introduced.

Here's some detail about the op array for the statement "expect false;":

//Optimizations=On Expectations=On (DEVELOPMENT)://
      
<code>
opcodes[2]:
    opcodes[0] -> ZEND_EXPCT expression
    opcodes[1] -> ZEND_RETURN
</code>

//Optimizations=Off Expectations=On://

<code>
    opcodes[3]:
        opcodes[0] -> ZEND_NOP
        opcodes[1] -> ZEND_EXPCT expression
        opcodes[2] -> ZEND_RETURN
</code>

//Optimizations=On Expectations=Off (PRODUCTION)//

<code>
    opcodes[1]:
        opcodes[0] -> ZEND_RETURN
</code>

//Optimizations=Off Expectations=Off://

<code>
    opcodes[2]:
        opcodes[0] -> ZEND_JMP opcodes[1]
        opcodes[1] -> ZEND_RETURN
</code>

The same opcodes for "assert("false")":

//Optimizations=Either Assertions=Either (LEGACY)://

<code>
    opcodes[3]:
        opcodes[0] -> ZEND_SEND_VAL string
        opcodes[1] -> ZEND_DO_FCALL assert
        opcodes[2] -> ZEND_RETURN
</code>

//When Assertions=Off opcodes[1] does not result in a call to  eval, but the actual call to assert cannot be optimized, dragging down productio
n considerably.//

===== Rejected Features =====

N/A