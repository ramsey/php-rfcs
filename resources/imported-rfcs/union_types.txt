====== PHP RFC: Union Types ======
  * Version: 1.0
  * Date: 2015-02-14
  * Author: Levi Morrison <levim@php.net>
  * Status: Under Discussion
  * First Published at: http://wiki.php.net/rfc/union_types

===== Introduction =====
In PHP 5.1 the ability to provide explicit types for parameters was added to PHP. It supported classes, interfaces and arrays. In PHP 5.4 the ''callable'' pseudo-type was added. The ability to provide explicit return types was added in PHP 7 but did not allow returning something or null, a commonly requested feature. Later an RFC for adding explicit scalar types was proposed and a few people wanted to know why there isn't a ''numeric'' type to handle the case where ''int'' and ''float'' are both accepted. I have personally wanted the ability to type against both ''array'' and ''Traversable'' in some of my libraries.

All of these requests and discussions suggest that the ability to accept multiple types for a parameter or return type could be useful. This RFC is an investigation into the feasibility of this idea and to flesh out the impact it would have on other parts of PHP. 

===== Proposal =====
This RFC proposes the ability to define multiple possible types for a parameter or return type and calls them "union types". A value passes the type-check for a union type if the value would pass any one of the members the union. A single vertical bar (OR) is placed between each of the two or more types.

Here is an example of a parameter accepting either an ''array'' or a ''Traversable'' and no other types:

<PHP>
function print_each(Array | Traversable $in) {
    foreach ($in as $value) {
        echo $value, PHP_EOL;
    }
}

print_each(['Bob', 'Joe', 'Levi']); // ok
print_each(new ArrayObject(['Bob', 'Joe', 'Levi'])); // ok
print_each(new stdclass()); // not ok
</PHP>

There can be more than two types in the union. As an example, it is somewhat common for a routine that interacts with a database to have one of three results:

  - Successfully found results
  - Successfully found no results
  - There was an error

This could be modeled with a union of three types: <php> function get_user(string $id): User | Error | Null;</php> I have seen projects that do return one of those three types; they just can't model it strictly and rely on unrestricted dynamic types.

To cover the common use-case of returning some type or null the null type needs to be permitted in a type declaration. The name is already reserved and the documentation already documents that null is both a type and a value. Previously it was not a helpful type declaration - if something is always passed null then there doesn't need to be a parameter at all, and if a function always returns null then there is no need to assign it. With the introduction of union types it becomes helpful and so this RFC proposes allowing it in type declarations:

<PHP>
function lookup_user(string $id): User | Null;
</PHP>

===== Proposed PHP Version(s) =====
This RFC targets PHP version 7.1.

===== Open Issues =====
==== Weak Scalar Types ====
PHP 7 allows weak scalar types. There is a question of how things will get converted in some situations when used in unions. As an example, if we have a union type of ''int'' and ''float'' and are passed the string "10" how is it converted?

<PHP>
function f(int | float $number) {
    return $number * 2;
}
f("10");
</PHP>

Would it be converted to ''int(10)'' or ''float(10)'', since either is acceptable? Does it matter given they are both acceptable?

This issue is avoided if a parameter type exactly matches the input type or if PHP is in strict type mode.

==== Standalone Null Type ====
This RFC permits the null type to be used in type declarations such as ''Foo | Null''. While it isn't very helpful it doesn't cause any harm to permit only ''Null'': <php>function foo(): Null;</php> However, some people feel it may be redundant with ''void''((It is this RFC author's opinion that ''void'' was a mistake given that ''Null'' already existed and PHP will always return null if return value is omitted.)).

==== Reflection ====
There isn't any part of our current Reflection extension that can deal with union types. This will require some thought.

===== Future Scope =====
This sections details areas where the feature might be improved in future, but that are not currently proposed in this RFC.

==== Long Type Expressions ====
Since you can create a chain of types the names can get quite lengthy. Even the fairly short union type of ''Array | Traversable'' can be repetitive to type out. Should a mechanism to provide type aliases exist?

<PHP>
type Iterable = Array | Traversable;

function map(Callable $f, Iterable $input): Iterable {
    foreach ($input as $key => $value) {
        yield $key => $f($value);
    }
}

function filter(Callable $f, Iterable $input): Iterable {
    foreach ($input as $key => $value) {
        if ($value) {
            yield $key => $value;
        }
    }
}
</PHP>

It may also be advantageous for implementation reasons to define a type name for an expression. 

==== False ====

Peter Cowburn (salathe) has suggested that being able to explicitly use ''| false'' for return types could be helpful as this is a common idiom in PHP's standard functions. As an example, the function signature for ''strpos'' could change:

<PHP>// from
strpos ( string $haystack , mixed $needle [, int $offset = 0 ] ): mixed
// to
strpos ( string $haystack , mixed $needle [, int $offset = 0 ] ): int | false</PHP>

''false'' is not a type in user-land but it is internally. This is possible if we want to allow it.

===== Proposed Voting Choices =====
This RFC requires that two-thirds of voters vote in favor of the RFC to pass.

===== Patches and Tests =====

Bob Weinand and Joe Watkins have made a proof-of-concept patch that also has some other experimental features: https://github.com/php/php-src/pull/1887.

===== References =====

  * Original announcement on Mailing List of rationale for this feature: http://news.php.net/php.internals/92252
  * Official Under Discussion Announcment: http://news.php.net/php.internals/92274