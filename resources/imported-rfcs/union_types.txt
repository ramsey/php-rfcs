====== PHP RFC: Union Types ======
  * Version: 1.0
  * Date: 2015-02-14
  * Author: Levi Morrison <levim@php.net>, Bob Weinand <bobwei9@hotmail.com>
  * Status: Under Discussion
  * First Published at: http://wiki.php.net/rfc/union_types

===== Introduction =====
In PHP 5.1 the ability to provide explicit types for parameters was added to PHP. It supported classes, interfaces and arrays. In PHP 5.4 the ''callable'' pseudo-type was added. The ability to provide explicit return types was added in PHP 7. PHP 7.1 introduced nullable types; A special union of any type and null.

Other commonly requested unions include ''array'' and ''Traversable'', and ''int'' and ''float''.

All of these requests and discussions suggest that the ability to accept multiple types for a parameter or return type could be useful. This RFC is an investigation into the feasibility of this idea and to flesh out the impact it would have on other parts of PHP. 

===== Proposal =====
This RFC proposes the ability to define multiple possible types for a parameter or return type and calls them "union types". A union typed value passes the type check if the value would pass any one of the types in the union. A single vertical bar (OR) is placed between types.

Here is an example of a parameter accepting either an ''array'' or a ''Traversable'' and no other types:

<PHP>
function print_each(Array | Traversable $in) {
    foreach ($in as $value) {
        echo $value, PHP_EOL;
    }
}

print_each(['Bob', 'Joe', 'Levi']); // ok
print_each(new ArrayObject(['Bob', 'Joe', 'Levi'])); // ok
print_each(new stdclass()); // not ok
</PHP>

There can be more than two types in the union. As an example, it is somewhat common for a routine that interacts with a database to have one of three results:

  - Successfully found results
  - Successfully found no results
  - There was an error

This could be modelled with a union: <php> function get_user(string $id): User | Error | Null;</php>

==== Variance ====

Return types are covariant: it is possible to remove types from the union in child functions.

Parameter types are contravariant: it is possible to add types to the union in child functions.

<PHP>
interface Foo {
    function pos(string $baz): int | false;
}
interface Bar extends Foo {
    function pos(string | Stringable $baz): int;
}
</PHP>

==== Weak Scalar Types ====

=== Problem ===
PHP 7 allows weak scalar types. There is a question of how things will get converted in some situations when used in unions. As an example, if we have a union type of ''int'' and ''float'' and are passed the string "10" how is it converted?

<PHP>
function f(int | float $number) {
    return $number * 2;
}
f("10");
</PHP>

Would it be converted to ''int(10)'' or ''float(10)'', since either is acceptable? Does it matter given they are both acceptable?

=== Solution ===

Primarily, this issue is avoided if a parameter type exactly matches the input type or if PHP is in strict type mode.

With the only exception that an ''int(10)'' passed to a parameter requiring float as one of its types, but not ''int'' (e.g. ''string | float''), will be, in accordance with normal handling of integers passed to floats, coerced to ''float(10)''.

Otherwise, the only solution is to have certain rules, which are made in order to be as lossless as possible (in that order):

  * If object passed, cast to (if allowed) string
  * If non-scalar passed, fail the conversion
  * If boolean passed, cast to (if allowed, in that order) long, double, string
  * If long passed, cast to (if allowed, in that order) string, boolean
  * If double passed, cast to (if allowed, in that order) long if exact match or string not allowed, string, boolean
  * If string passed and numeric cast possible, cast to long or double
  * If possible to cast to boolean
  * Else fail the conversion

The RFC authors are aware that this is quite a complex handling, but it behaves quite sanely in general. The premise of weak typing is to succeed whenever a conversion is possible. Thus, failing is not an option in most cases (well, if you pass ''"lalala"'' to a function requiring ''int | float'', there is nothing we can do, but fail). The only thing we can do, is ensuring sensible conversion, minimizing loss.

==== Nullable types ====
To cover the common use-case of returning some type or ''null'', the ''null'' type needs to be permitted in a type declaration. The name is already reserved and the documentation already documents that ''null'' is both a type and a value. Previously it was not a helpful type declaration - if something is always passed ''null'' then there doesn't need to be a parameter at all, and if a function always returns ''null'' then there is no need to assign it. With the introduction of union types it becomes helpful and so this RFC proposes allowing ''null'' in unions:

<PHP>
function lookup_user(string $id): User | null;
</PHP>

While this is currently already possible via nullable type support ''?Type'', within union types, it is problematic:

''?Foo | Bar'' is pretty weird, it reads like "(nullable Foo) or (Bar)". 

This RFC disallows ''?'' being used in combination with union types. Thus ''Foo | Bar | null'' is allowed, but not ''?FooÂ | Bar''.

Also, it is the RFC authors opinion is that ''Union | null'' looks much better, is more visible and expressive. A single ''?'' may be more concise, but it also much easier to miss when reading. Using '' | null'' solves this.

On top of that, it is redundant: having two ways to do a same thing is not great here. 

Hence this RFC proposes a vote on whether ''?'' shall be replaced by ''| null'' in general. 

==== True/False ====
Peter Cowburn (salathe) has suggested that being able to explicitly use ''| false'' for return types could be helpful as this is a common idiom in PHP's standard functions. As an example, the function signature for ''strpos'' could change:

<PHP>// from
strpos ( string $haystack , mixed $needle [, int $offset = 0 ] ): mixed
// to
strpos ( string $haystack , mixed $needle [, int $offset = 0 ] ): int | false</PHP>

Also ''false'' and ''true'' are not types in user-land, but they are internally.

This RFC proposes a vote to decide if ''true'' and ''false'' should be supported for unions.

==== Reflection ====
This RFC proposes the addition of <php>ReflectionType::isUnion(): bool;</php> to check whether the type is an union type.

ReflectionType::__toString() will now provide a full union type as string; e.g. ''"int | float | NumberObject"''.

===== Proposed PHP Version(s) =====
This RFC targets PHP version 7.1.

===== Future Scope =====
This sections details areas where the feature might be improved in future, but that are not currently proposed in this RFC.

==== Long Type Expressions ====
Since you can create a chain of types the names can get quite lengthy. Even the fairly short union type of ''Array | Traversable'' can be repetitive to type out. Should a mechanism to provide type aliases exist?

<PHP>
type Iterable = Array | Traversable;

function map(Callable $f, Iterable $input): Iterable {
    foreach ($input as $key => $value) {
        yield $key => $f($value);
    }
}

function filter(Callable $f, Iterable $input): Iterable {
    foreach ($input as $key => $value) {
        if ($value) {
            yield $key => $value;
        }
    }
}
</PHP>

It may also be advantageous for implementation reasons to define a type name for an expression. 

===== Proposed Voting Choices =====
This RFC requires that two-thirds of voters vote in favor of the RFC to pass.

Additionally, there are two 50%+1 votes:

  * on replacing ''?QuestionMarkNullables'' by ''union | null'',
  * and the true/false types (for unions only).

===== Patches and Tests =====

Bob Weinand and Joe Watkins have made a proof-of-concept patch that also has some other experimental features: https://github.com/php/php-src/pull/1887.

This patch is principally fine to be merged (intersection types are still included, but may be easily removed at any point).

===== References =====

  * Original announcement on Mailing List of rationale for this feature: http://news.php.net/php.internals/92252
  * Official Under Discussion Announcment: http://news.php.net/php.internals/92274