====== PHP RFC: New in initializers ======
  * Date: 2021-03-02
  * Author: Nikita Popov <nikic@php.net>
  * Status: Under Discussion
  * Proposed Version: PHP 8.1
  * Implementation: https://github.com/php/php-src/pull/6746

===== Introduction =====

This RFC proposes to allow use of ''new'' expressions inside initializer expressions, including for property and parameter default values.

Currently, code such as the following is not permitted:

<PHP>
class Test {
    public function __construct(
        private Logger $logger = new NullLogger,
    ) {}
}
</PHP>

Instead, it is necessary to write code along the following lines:

<PHP>
class Test {
    private Logger $logger;

    public function __construct(
        ?Logger $logger = null,
    ) {
        $this->logger = $logger ?? new NullLogger;
    }
}
</PHP>

This makes the actual default value less obvious (from an API contract perspective), and requires the use of a nullable argument.

This RFC proposes to relax this restriction and allow the use of ''new'' inside all initializer expressions.

===== Proposal =====

''new'' expressions are allowed as part of initializer expressions. It is possible to pass arguments to the constructor, including the use of named arguments:

<PHP>
// All allowed:
function test(
    $foo = new A,
    $bar = new B(1),
    $baz = new C(x: 2),
) {
}
</PHP>

The use of a dynamic or non-string class name or an anonymous class is not allowed. The use of argument unpacking is not allowed. The use of unsupported expressions as arguments is not allowed. 

<PHP>
// All not allowed (compile-time error):
function test(
    $a = new (CLASS_NAME_CONSTANT)(), // dynamic class name
    $b = new class {}, // anonymous class
    $c = new A(...[]), // argument unpacking
    $d = new B($abc), // unsupported constant expression
) {}
</PHP>

Affected positions are static variable intializers, constant and class constant initializers, static and non-static property intializers, parameter default values, as well as attribute arguments:

<PHP>
static $x = new Foo;

const C = new Foo;

#[AnAttribute(new Foo)]
class Test {
    const C = new Foo;
    public static $prop = new Foo;
    public $prop = new Foo;
}

function test($param = new Foo) {}
</PHP>

==== Order of evaluation ====

Initializer expressions could always contain side-effects through autoloaders or error handlers. However, support for ''new'' and the accompanying construct calls make side-effect a more first-class citizen in initializer expressions, so it is worthwhile to specify when and in what order they are evaluated. This depends on the type of initializer:

  * Static variable initializers are evaluated when control flow reaches the static variable declaration.
  * Global constant initializers are evaluated when control flow reaches the constant declaration.
  * Attribute arguments are evaluated from left to right on every call of ''ReflectionAttribute::getArguments()'' or ''ReflectionAttribute::newInstance()''.
  * Parameter default values are evaluated from left to right on every call to the function where the parameter is not explicitly passed.
  * Property default values are evaluated in order of declaration (with parent properties before properties declared in the class) when the object is instantiated. This happens before the constructor is invoked. If an exception is thrown during evaluation, the object destructor will not be invoked.
  * The time of evaluation for static properties and class constants is unspecified. Currently, all static property and class constant initializers are evaluated on certain first uses of the class. (TODO?)

==== Interaction with reflection ====

Initializers, or values based on initializers, can be accessed through Reflection in various ways. This section specifies how the different methods behave:

  * ''ReflectionFunctionAbstract::getStaticVariables()'': Returns the current value of the static variables and also forces evaluation of any initializers that haven't been reached yet.
  * ''ReflectionParameter::getDefaultValue()'': Evaluates the default value (on each call).
  * ''ReflectionParameter::isDefaultValueConstant()'' and ''ReflectionParameter::getDefaultValueConstantName()'': Do not evaluate the default value.
  * ''ReflectionClassConstant::getValue()'', ''ReflectionClass::getConstants()'' and ''ReflectionClass::getConstant()'': Returns value of the class constant(s), evaluating the initializer if this has not happened yet. (The returned value is the same as the actual value of the class constant, not a separate evaluation.)
  * ''ReflectionClass::getDefaultProperties()'' and ''ReflectionProperty::getDefaultValue()'': Evaluates initializers for both static and non-static properties on each call. (NOTE: Due to a pre-existing implementation bug, if opcache is not used, the current value is used instead of the default value for static properties. This is  incorrect, and should be fixed.)
  * ''ReflectionAttribute::getArguments()'' and ''ReflectionAttribute::newInstance()'': Evaluate attribute arguments on each call.
  * ''ReflectionObject::newInstanceWithoutConstructor()'': Evaluates and assigns default values, even though the constructor is not invoked. (TODO?)

==== Recursion protection ====

If the evaluation of an object property default value results in recursion, an ''Error'' exception is thrown:

<PHP>
class Test {
    public $test = new Test;
}

new Test;
// Error: Trying to recursively instantiate Test while evaluating default value for Test::$test
</PHP>

==== Trait property compatibility ====

When two traits declaring the same property are used in a class, a compatibility check is performed, which requires that both use the same initializer. Consider the following example:

<PHP>
trait T1 {
    public $prop = new A;
}
trait T2 {
    public $prop = new A;
}

class B {
    use T1, T2;
}
</PHP>

These properties are not compatible, because trait compatibility is determined using identity comparison (''==='') and both properties hold different instances of the same object. However, we do not want the compatibility check to actually evaluate the ''new'' expressions (and the side-effects this may entail). These should only be evaluated when an object is instantiated.

Initializer expressions are separated into two categories: Non-dynamic (all existing expression types) and dynamic (containing ''new'' -- or other side-effecting expression types in the future). If the initializer of a trait property is dynamic, then it will not be evaluated an always considered incompatible.

===== Backward Incompatible Changes =====

None.

===== Future Scope =====

This RFC is narrow in that it only adds support for ''new'' expressions. However, it also lays the technical groundwork for supporting other expressions like calls.

===== Vote  =====

Yes/No.
