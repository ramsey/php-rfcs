===== RFC: First-Class Object and Array Literals =====

==== Introduction ====

In modern web applications, [[http://json.org/|JSON]] has become ubiquitous.
Whether through serialization, such as when passing data to the end user's
browser and when consuming
[[http://www.flickr.com/services/api/response.json.html|JSON-powered web
services]], or as a query format, such as when interfacing with systems like
[[http://couchdb.org/|CouchDB]], [[http://mongodb.org/|MongoDB]] and
[[http://elasticsearch.org|ElasticSearch]], many current (and future) web
deployments (will) need to generate and consume JSON in some way.

[[http://www.ietf.org/rfc/rfc4627.txt|JSON]]
(in the not-necessarily-strict sense) is also the de facto way to
communicate between a web back-end and mobile applications.

This proposal calls for first-class JSON-like object and array literals
(a.k.a. primitives, constructs) in PHP.


==== Goal ====

The goal of this proposal is to simplify interaction with third-party
services and applications that speak JSON (or a JSON-like dialect), by
allowing first-class (inline) array and object literals.


==== Syntax ====

The proposed syntax is an inline, non-strict implementation of the syntax
defined in the [[http://www.ietf.org/rfc/rfc4627.txt|JSON Spec]]. Using
a strict syntax would not conform with the PHP Way, but E_NOTICE could be
raised in the same way that ''array(one %%=>%% 1)'' curently emits a notice.

Furthermore, JSON-proper is a serialization format, but this proposal
concerns a declaratative, inline, interpreted object literal format.

Point of discussion (see below): the key-value separator will be both PHP's
conventional %%=>%%, and the foreign-language convention: '':''.


==== Syntax Examples ====

<code php>
<?php
// new syntax for simple arrays:
$a = [1,2,'three'];
// equivalent to current:
$a = array(1,2,'three');

// associative arrays:
// (examples are equivalent; see discussion)
$a = ['one' => 1, 'two' => 2, 'three' => 'three'];
$a = ['one': 1, 'two': 2, 'three': 'three'];
// equivalent to current:
$a = array('one' => 1, 'two' => 2, 'three' => 'three');

// anonymous object:
// (examples are equivalent; see discussion)
$a = {'one': 1, 'two': 2, 'three': 3};
$a = {'one' => 1, 'two' => 2, 'three' => 3};
// equivalent to:
$a = new \StdClass;
$a->one = 1; $a->two = 2; $a->three = 'three';
// or:
$a = (object)array('one' => 1, 'two' => 2, 'three' => 'three');

// PHP conventions (dynamic keys/values)
$val = 'apple';
$record = {"favourite_fruit": $val};
// true expression:
$record->favourite_fruit == "apple";

$key = "colour";
$record = {$key: "red"};
echo $record->colour; // outputs "red"

$colour = "green";
$vehicle = "truck";
$record = {'notes': "Drives a {$colour} $vehicle."};
echo $record->notes; // outputs "Drives a green truck."

// inline functions:
$creditCard = '5105105105105100';
$doc = {"credit_card_reminder": substr($creditCard, -4)};
echo $doc->credit_card_reminder; // outputs "5100"

// 'invalid' keys:
$obj = {'key with spaces': 'still works'};
echo $obj->{'key with spaces'}; // outputs 'still works'
$doc = {'$set': {"has_logged_in": 'yes'}};
echo $doc->{'$set'}->has_logged_in; // outputs "yes"

?>
</code>

==== Benefits ====

The main benefit of this syntax directly relates to the stated goal:
simplified interoperability with third-party systems, such as browsers,
databases, and web services.

This goal is accomplished through the following benefits:

  * A more terse syntax that is still understood and easily readable. This is especially the case for object literals.
  * The ability to build code that uses existing examples for systems such as from the documentation of ElasticSearch without first translating the example from JSON to PHP's ''array()'' syntax.
  * Improved ability to debug directly against third party APIs (such as by pasting compatible object/array literal syntax from PHP into curl, which helps identify the source of the bug: your code or your data).
  * Improved communication with third party vendors (read: authors, for small open source projects), who often understand JSON and thus other literals, but not necessarily PHP.


==== Backward Compatibility Breaks ====

None known at the time of writing.
The special characters proposed in this RFC (''{'', ''}'', ''['', '']'',
'':'', and '','') /are/ currently in use, but never in the context of the
proposed syntax.


==== Existing Implementations ====

  * JavaScript (with which nearly all modern web apps must interface in some form) supports a very similar syntax. JavaScript (largely) supports a non-strict JSON implementation. The "JS" in JSON stands for JavaScript.
  * Python supports a very similar syntax for defining lists and sets (which are somewhat analogous to PHP's arrays (non-associative)), and dictionaries, which are similar to PHP's associative arrays and anonymous (''StdClass'') objects.
  * Ruby 1.9.1 added [[http://webonrails.com/2009/02/06/ruby-191-hash/|syntax improvements]] for its hashes to simplify the syntax and improve readability much like this RFC proposes.


==== Differences from Other Implementations ====

  * PHP's associative arrays are more malleable than other implementations.
  * This proposal calls for a syntax that is much less strict than proper, on-spec JSON.


==== Why not just use ''json_decode($literalString)''? ====

Converting literal notation to PHP strings and then into objects/arrays is
problematic for several reasons:

  * Inline escaping is necessary for special characters; there is a significant amount of cognitive overhead required in keeping a mental stack of escape depth.
  * Inline injection of variables or functions requires confusing and verbose string concatenation.
  * Tools (editors, static analysis tools) see strings as strings; literals are more explicit.
  * ''create_function()'' was replaced by first-class closures/lambdas for similar reasons.
  * In-line SQL has similar problems, and requires workarounds like placeholders.
  * Performance concerns: encoding/re-encoding, memory usage.


==== Further Discussion Required ====

  * Strictness of unquoted keys.
  * Support %%=>%% in addition to '':'' as a key:value separator.
  * possibility of simply not supporting the ''\u###'' syntax for Unicode characters in literal strings (just like the rest of PHP).
  * Should mixed-format (numeric and associative arrays) be allowed? (e.g. ''[1,'two':2, 3]'')

