====== Request for Comments: Property get/set syntax - As Implemented ======
  * Version: 1.0
  * Date: 2011-12-21
  * Author: Clint Priest <phpdev at zerocue dot com>
  * Status: Mostly Completed

==== Introduction ====
This document describes the accessor syntax As Implemented.  The RFC which the implementation was crafted from is located here: https://wiki.php.net/rfc/propertygetsetsyntax

==== What Are Properties? ====

Properties provide a clean, easy to understand and unified syntax for get/set accessors.  They allow incoming and outgoing requests (gets and sets) from a class member to be run through a method first.  This method can perform validation or a transformation, or update other areas of the class.  Properties do not even have to be associated with a class member, and can generate their own data on-the-fly.
 

===== Syntax =====

==== Basic Syntax ====

This is the property syntax for accessors as implemented.

<code php>
class TimePeriod {
    private $seconds;

    // Accessor properties are implemented just like you would define an actual property
    public $Hours {
        get { return $this->seconds / 3600; }
        
        // In the set accessor, the variable $value holds the incoming value to be "set" 
        set { $this->seconds = $value * 3600; } 
    }
};
</code>

<code php>
// Accessing the property is the same as accessing a class member
$time = new TimePeriod();
$time->Hours = 12;  // Stored as 43200
echo $time->Hours;  // Outputs 12
</code>

Note that "get" and "set" were not made to be new keywords, they are processed as strings by the parser.

==== Read-Only And Write-Only Properties ====

=== read-only keyword ===
//new keyword//

You can use the read-only keyword in the definition of the property to enforce the property is read only.  No setter may be defined and an attempt to set the property results in a fatal error.

<code php>
class TimePeriod {
    private $seconds;

    // This property has specified the read-only keyword and therefore is read-only
    public read-only $Hours {
        get { return $this->seconds / 3600; }
        // Setter may not be defined 
    }
};

// Results in Fatal Error 

$o = new TimePeriod();
$o->Hours = 4;
</code>

=== write-only keyword ===
//new keyword//

You can use the write-only keyword in the definition of the property to enforce the property is write only.  No getter may be defined and an attempt to get the property results in a fatal error.

<code php>
class TimePeriod {
    private $seconds;

    // This property has specified the write-only keyword and therefore is write only 
    public write-only $Hours {
        // Getter may not be defined 
        set { $this->seconds = $value * 3600; } 
    }
};

// Results in Fatal Error 

$o = new TimePeriod();
echo $o->Hours;
</code>

=== No read-only or write-only=== 
Omitting a read-only or write-only will cause the %%__%%get() or %%__%%set() to be called for the missing accessor, as if the property did not exist.  This mimics the behavior of the prior work and allows lazy initialization of properties.

<code php>
class Sample {

    // This property sets its-self on first get, subsequent uses of $Iterator
    // will result in the value specified, rather than calling the getter.
    public $Iterator {
        get { return $this->Iterator = new DirectoryIterator('*.*'); }
    }
};

$o = new Sample();

// Calls getter for $Iterator
$Iterator = $o->Iterator;

// Retrieves initialized value of $Iterator from first call to accessor
$Iterator2 = $o->Iterator;

// $Iterator === $Iterator2
</code>

==== Asymmetric Accessor Accessibility ====
Properties can have different levels of visibility for the get and set methods.  This is achieved by setting either the get or set method to a lower visibility than the property is set to.

<code php>
class TimePeriod {
    private $seconds = 3600;

    public $Hours {
        get { return $this->seconds / 3600; }
        protected set { $this->seconds = $value * 3600; }
    }
};
</code>

<code php>
$o = new TimePeriod();
echo $o->Hours;    // Prints 1
$o->Hours = 12;    // Error, unable to set protected property
</code>

In the above example the getter inherits the public access level of the property definition.


==== Interface Properties ====

Interfaces may define property declarations, without a body.  The purpose of this is to define properties that must exist in an implementing class, and may indicate if they are read-write, read-only, or write-only.

When a class implements an interface that defines a getter, it can add in a set method to turn the property into a read-write property.  The inverse is also true for implementing an interface with a setter only.  This is because interfaces are designed to enforce what //should be// in a class, and not what //should not be// in a class.

<code php>
interface iSampleInterface {
    public $MyProperty {
        get;
        set;
    }
};
</code>

==== Overloading Properties ====

Properties can be overloaded in extending classes.  An overloaded property can replace an existing get or set declaration without touching the other, replace both the get and set declarations, or add an omitted get or set declaration turning the property into a read-write property.  Additionally, a property may have its visibility increased through overloading.  Get or set declarations cannot be removed or hidden by the child class in any way.

<code php>
class TimePeriod {
    protected $Seconds = 3600;

    public $Hours {
        get { return $this->Seconds / 3600; }
        set { $this->Seconds = $value * 3600; }
    }

    // This property is read-only
    public read-only $Minutes {
        get { return $this->Seconds / 60; }
    }

    public $Milliseconds {
        // This accessor is public
        get { return $this->Seconds * 60; }

        // This accessor is protected
        protected set { $this->Seconds = $value * 3600; }
    }
};

class HalfTimePeriod extends TimePeriod {
    public $Hours {
        // The get method is being overloaded
        get { return ($this->seconds / 3600) / 2; }

        // Notice that we are not also overloading the set method
        // The base set method will still be called
    }

    public $Minutes {
        // A set method is added, turning this property into a read-write property instead of read-only
        set { $this->seconds = $value * 60; }
    }

    public $Milliseconds {
        // A property method can have its visibility increased in a child class, just like regular PHP methods
        // This method is now public instead of protected
        public set {
            /***************************
             *** NOT YET IMPLEMENTED ***
             ***************************/
            // You can access a base class property explicitly, just like accessing a base
            // class member or method (parent:: could also be used here)
            TimePeriod::$Milliseconds = $value;
        }
    }
};
</code>

==== Final Properties ====

Properties declared final are not allowed to be overloaded in a child class, just like final methods.

<code php>
class TimePeriod {
    private $Seconds;

    public final $Hours {
        get { return $this->seconds / 3600; }
        set { $this->seconds = $value * 3600; }
    }
};

class HalfTimePeriod extends TimePeriod {
    private $Seconds;

    // This attempt to overload the property "Hours" will throw an error because it was declared final in the base class
    public $Hours {
        get { return ($this->seconds / 3600) / 2; }
    }
};
</code>

**__Final property methods__**

The get or set method of a property can be declared "final" independently of each other.  This would allow for one of them to be overloaded, but not the other.

<code php>
class TimePeriod {
    private $Seconds;

    // Notice there is no "final" keyword on the property declaration
    public $Hours {
        final get { return $this->seconds / 3600; }// Only the get method is declared final
        set { $this->seconds = $value * 3600; }
    }
};

class HalfTimePeriod extends TimePeriod {
    private $Seconds;

    public $Hours {
        // This attempt to overload the get method of the "Hours" will throw an error
        // because it was declared final in the base class
        get { return ($this->seconds / 3600) / 2; }
                                                   
        // This would be accepted
        set ( $this->seconds = ($value * 3600) * 2; )
    }
};
</code>

==== Static Properties ====
** Not Yet Implemented **

Static properties act nearly identical to regular properties, except in a static context.

<code php>
class TimePeriod {
    private static $Seconds;

    public static $Hours {
        get { return self::$Seconds / 3600; }
        set { self::$Seconds = $value * 3600; }
    }
};
</code>

<code php>
// Accessing a static property is the same as accessing a static class member
TimePeriod::$Hours = 12;  // Stored as 43200
echo TimePeriod::$Hours;  // Outputs 12
</code>

===== Implementation =====

Accessor information is stored in a new zend_accessor_info struct which contains a zend_uint flags and two function pointers.  These structures are stored in a new HashTable property in a zend_class_entry structure named accessors.  They are indexed by the hash_value of the property name and are thus quickly accessed during property resolution.

<code c>
typedef struct _zend_accessor_info {
	zend_uint	flags;
	zend_function *getter;
	zend_function *setter;
} zend_accessor_info;
</code>

Internally the getters and setters are implemented as ordinary functions (with appropriate access levels) with specialized names.  Getter/Setters for a property named $Hours would be %%__getHours()%% and %%__setHours($value)%% respectively.

Four new function flags have been defined:
<code c>
#define ZEND_ACC_IS_GETTER    0x10000000
#define ZEND_ACC_IS_SETTER    0x20000000
#define ZEND_ACC_IS_ACCESSOR  0x30000000	/* Mask */

#define ZEND_ACC_READONLY     0x40000000
#define ZEND_ACC_WRITEONLY    0x80000000
</code>

 * %%__get()%% and %%__set()%% guards were used and the functionality is the same with the new accessors.

 * Error producing lines have been modified to check the function for ZEND_ACC_IS_ACCESSOR mask with more appropriate error report occuring.  For example: Cannot override final property getter TimePeriod::$Hours

==== Safety Checks ====

**read-only and write-only keywords**

These keywords may not be specified multiple times, nor may they be used with regular properties (non-accessor) or methods.


===== Tests =====
  * 2011-12-21 - 21 Test Cases Created

===== References =====
  * [[https://wiki.php.net/rfc/propertygetsetsyntax|Property Get/Set Syntax RFC by Dennis Robinson]]

===== Changelog =====
  - 2011-12-21 Clint Priest: "As Implemented" document created based in large part by original RFC


===== Creation Notes =====
 * Add mention of auto-property (get; set;)
 * Add mention of Reflection plans
 * Add mention of Type Hinting plans
